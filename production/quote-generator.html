<!DOCTYPE html>
<html lang="en">
    <head>
        <link
            href="https://db.onlinewebfonts.com/c/28c0ba929947563500b21da15a88c6fe?family=TacticSans-Reg"
            rel="stylesheet"
        />
        <meta charset="utf-8" />
        <meta
            content="width=device-width, initial-scale=1.0"
            name="viewport"
        />
        <title>Cocoon Aluminum Works - Window & Door Quote</title>
        <link
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
            rel="stylesheet"
        />
        <link
            href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&family=Open+Sans:wght@300;400;600&display=swap"
            rel="stylesheet"
        />

        <!-- Firebase SDK -->
        <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
        <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
        <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>

        <!-- Your Firebase config -->
        <script src="config.js"></script>
        <script src="auth.js"></script>

        <style>
            /* All existing styles remain unchanged */
            /* Only adding new styles for the profile selection */
            .profile-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                gap: 20px;
                margin-top: 20px;
            }

            .profile-card {
                background: white;
                border: 1px solid #e0e0e0;
                border-radius: 8px;
                padding: 20px;
                transition: all 0.3s;
                cursor: pointer;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            }

            .profile-card:hover {
                transform: translateY(-5px);
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
                border-color: #a72036;
            }

            .profile-card.selected {
                border: 2px solid #a72036;
                background: rgba(167, 32, 54, 0.03);
            }

            .profile-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
                padding-bottom: 10px;
                border-bottom: 1px solid #eee;
            }

            .profile-brand {
                font-weight: 600;
                color: #303038;
                font-size: 1.1rem;
            }

            .profile-code {
                background: #f0f0f0;
                padding: 3px 8px;
                border-radius: 4px;
                font-size: 0.85rem;
                font-family: monospace;
            }

            .profile-name {
                font-size: 1.3rem;
                color: #a72036;
                margin-bottom: 10px;
                font-weight: 600;
            }

            .profile-specs {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
                margin-bottom: 15px;
            }

            .spec-item {
                display: flex;
                flex-direction: column;
            }

            .spec-label {
                font-size: 0.85rem;
                color: #777;
            }

            .spec-value {
                font-weight: 600;
                color: #303038;
            }

            .profile-price {
                font-size: 1.1rem;
                font-weight: 700;
                color: #303038;
                text-align: center;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px dashed #ddd;
            }

            .profile-notice {
                background: rgba(249, 188, 119, 0.2);
                border-radius: 4px;
                padding: 8px 12px;
                font-size: 0.9rem;
                margin-top: 15px;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .profile-notice i {
                color: #f9bc77;
            }

            .loading-profiles {
                text-align: center;
                padding: 30px;
                font-size: 1.1rem;
                color: 777;
            }

            .loading-profiles i {
                font-size: 2rem;
                margin-bottom: 15px;
                color: #a72036;
                animation: spin 1.5s linear infinite;
            }

            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }
                100% {
                    transform: rotate(360deg);
                }
            }

            .no-profiles {
                text-align: center;
                padding: 30px;
                background: rgba(167, 32, 54, 0.05);
                border-radius: 8px;
            }

            .no-profiles i {
                font-size: 2rem;
                margin-bottom: 15px;
                color: #a72036;
            }

            /* New styles for curtain wall and export */
            .curtain-wall-fields {
                display: none;
                background: rgba(167, 32, 54, 0.05);
                padding: 20px;
                border-radius: 8px;
                margin-top: 15px;
                border-left: 3px solid #a72036;
            }

            /* Embedded Curtain Wall Designer Styles */
            .curtain-designer-embedded {
                background: white;
                border-radius: 12px;
                padding: 20px;
                margin: 15px 0;
                border: 2px solid #e0e0e0;
            }

            .curtain-designer-header {
                text-align: center;
                margin-bottom: 25px;
                padding-bottom: 15px;
                border-bottom: 3px solid var(--cocoon-primary);
            }

            .curtain-designer-header h3 {
                color: var(--cocoon-primary);
                font-size: 1.8rem;
                margin-bottom: 10px;
            }

            .curtain-designer-subtitle {
                color: var(--cocoon-dark);
                font-size: 1rem;
                opacity: 0.8;
            }

            .curtain-app-container {
                display: grid;
                grid-template-columns: 1fr;
                gap: 20px;
            }

            @media (min-width: 992px) {
                .curtain-app-container {
                    grid-template-columns: 300px 1fr;
                    grid-template-areas:
                        "curtain-controls curtain-design-area"
                        "curtain-calculations curtain-design-area";
                }
                .curtain-control-panel {
                    grid-area: curtain-controls;
                }
                .curtain-design-area-wrapper {
                    grid-area: curtain-design-area;
                }
                .curtain-calculations-panel {
                    grid-area: curtain-calculations;
                }
            }

            .curtain-card {
                background: var(--cocoon-white);
                border-radius: 12px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
                padding: 20px;
                margin-bottom: 20px;
            }

            .curtain-card-title {
                color: var(--cocoon-primary);
                margin-bottom: 15px;
                padding-bottom: 10px;
                border-bottom: 2px solid var(--cocoon-light);
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .curtain-card-title i {
                font-size: 1.4rem;
            }

            .curtain-controls {
                display: grid;
                grid-template-columns: 1fr;
                gap: 15px;
                margin-bottom: 20px;
            }

            .curtain-control-group {
                display: flex;
                flex-direction: column;
            }

            .curtain-control-group label {
                font-weight: 600;
                margin-bottom: 8px;
                color: var(--cocoon-dark);
                font-size: 0.95rem;
            }

            .curtain-mode-selector {
                display: flex;
                gap: 10px;
                flex-wrap: wrap;
                margin-bottom: 15px;
            }

            .curtain-mode-btn {
                flex: 1;
                min-width: 100px;
                padding: 12px;
                border-radius: 8px;
                text-align: center;
                cursor: pointer;
                transition: all 0.3s;
                border: 2px solid #e0e0e0;
                background: white;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 8px;
            }

            .curtain-mode-btn i {
                font-size: 1.4rem;
            }

            .curtain-mode-btn.active {
                border-color: var(--cocoon-primary);
                background: rgba(167, 32, 54, 0.05);
            }

            .curtain-mode-btn:hover {
                border-color: var(--cocoon-primary);
            }

            .curtain-design-area {
                position: relative;
                overflow: auto;
                margin: 0 auto;
                border: 2px dashed #ccc;
                border-radius: 8px;
                background: white;
                min-height: 400px;
                touch-action: none;
                padding: 20px;
            }

            .curtain-panel-grid {
                position: relative;
                margin: 0 auto;
                width: 100%;
                max-width: 600px;
                min-height: 400px;
                padding: 8px;
                background: #f8f8f8;
                border-radius: 8px;
            }

            .curtain-panel {
                border: 2px solid #ddd;
                background: white;
                position: absolute;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: all 0.2s;
                min-width: 30px;
                min-height: 30px;
                text-align: center;
                padding: 10px;
                flex-direction: column;
                border-radius: 6px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                box-sizing: border-box;
            }

            .curtain-panel.merged {
                border: 3px solid #a72036;
                background: rgba(167, 32, 54, 0.1);
                z-index: 10;
                border-radius: 6px;
                box-shadow: 0 4px 8px rgba(167, 32, 54, 0.2);
            }

            .curtain-panel:hover {
                transform: scale(1.02);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            }

            .curtain-panel.structure {
                background: #e9f7ef;
                border-color: #2ecc71;
            }

            .curtain-panel.window {
                background: #e3f2fd;
                border-color: #42a5f5;
            }

            .curtain-panel.door {
                background: #ffecb3;
                border-color: #ffca28;
            }

            .curtain-panel.selected {
                border: 3px solid var(--cocoon-primary);
                box-shadow: 0 0 0 3px rgba(167, 32, 54, 0.2);
                border-radius: 6px;
            }

            .curtain-panel .panel-type {
                font-size: 0.8rem;
                font-weight: 600;
                margin-top: 5px;
            }

            .curtain-panel .panel-size {
                font-size: 0.75rem;
                color: #666;
            }

            .curtain-panel .panel-id {
                position: absolute;
                top: 3px;
                left: 3px;
                background: rgba(0, 0, 0, 0.2);
                color: white;
                padding: 2px 5px;
                border-radius: 3px;
                font-size: 0.7rem;
            }

            .curtain-results {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 15px;
                margin-top: 20px;
            }

            .curtain-result-card {
                background: rgba(167, 32, 54, 0.05);
                border-left: 3px solid var(--cocoon-primary);
                padding: 15px;
                border-radius: 8px;
            }

            .curtain-result-value {
                font-size: 1.8rem;
                font-weight: 700;
                color: var(--cocoon-primary);
                margin-top: 5px;
            }

            .curtain-result-label {
                font-size: 0.9rem;
                color: #777;
            }

            .curtain-action-buttons {
                display: flex;
                gap: 10px;
                margin-top: 20px;
                flex-wrap: wrap;
            }

            .curtain-instructions {
                background: rgba(249, 188, 119, 0.15);
                border-left: 4px solid var(--cocoon-light);
                padding: 15px;
                border-radius: 8px;
                margin: 15px 0;
                font-size: 0.95rem;
            }

            .curtain-instructions ul {
                padding-left: 20px;
                margin-top: 10px;
            }

            .curtain-instructions li {
                margin-bottom: 8px;
            }

            .curtain-dimension-inputs {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 15px;
            }

            .curtain-size-inputs {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
                gap: 8px;
                margin-top: 8px;
            }

            .curtain-size-inputs input {
                padding: 10px;
                border: 1px solid #ddd;
                border-radius: 6px;
                text-align: center;
                font-size: 0.9rem;
                font-weight: 500;
            }

            .curtain-size-inputs input:focus {
                border-color: var(--cocoon-primary);
                outline: none;
                box-shadow: 0 0 0 2px rgba(167, 32, 54, 0.2);
            }

            .curtain-size-inputs input::placeholder {
                color: #999;
            }

            .curtain-panel-info {
                margin-top: 10px;
                padding: 10px;
                background: #f8f8f8;
                border-radius: 6px;
                font-size: 0.9rem;
            }

            .curtain-panel-actions {
                display: flex;
                gap: 8px;
                margin-top: 10px;
                flex-wrap: wrap;
            }

            .curtain-panel-actions button {
                padding: 8px 12px;
                font-size: 0.9rem;
            }

            .curtain-calculation-details {
                margin-top: 20px;
                padding: 15px;
                background: rgba(167, 32, 54, 0.05);
                border-radius: 8px;
                font-size: 0.9rem;
            }

            .curtain-calculation-details h4 {
                color: var(--cocoon-primary);
                margin-bottom: 10px;
            }

            .curtain-detail-item {
                display: flex;
                justify-content: space-between;
                padding: 5px 0;
                border-bottom: 1px dashed #ddd;
            }

            .curtain-detail-item:last-child {
                border-bottom: none;
                font-weight: bold;
            }

            .curtain-calc-breakdown {
                background: #f9f9f9;
                border-radius: 8px;
                padding: 15px;
                margin-top: 15px;
                border: 1px solid #eee;
            }

            .curtain-calc-breakdown h4 {
                color: var(--cocoon-primary);
                margin-bottom: 10px;
            }

            .curtain-merge-hint {
                text-align: center;
                font-size: 0.85rem;
                color: #666;
                padding: 10px 15px;
                margin: 10px 0;
                background: #f8f8f8;
                border-radius: 6px;
                border: 1px solid #e0e0e0;
            }

            .curtain-highlight {
                animation: curtain-highlight 1.5s ease;
            }

            @keyframes curtain-highlight {
                0% {
                    background-color: rgba(167, 32, 54, 0.1);
                }
                100% {
                    background-color: transparent;
                }
            }

            @media (max-width: 768px) {
                .curtain-dimension-inputs {
                    grid-template-columns: 1fr;
                }

                .curtain-action-buttons {
                    flex-direction: column;
                }

                .curtain-panel {
                    min-width: 60px;
                    min-height: 60px;
                }
            }

            .project-totals {
                background: #f8f8f8;
                border-radius: 8px;
                padding: 20px;
                margin-top: 20px;
                border: 1px solid #eaeaea;
            }

            .project-totals h3 {
                color: #a72036;
                margin-bottom: 15px;
                padding-bottom: 10px;
                border-bottom: 1px solid #ddd;
            }

            .total-row {
                display: flex;
                justify-content: space-between;
                padding: 10px 0;
                border-bottom: 1px solid #eee;
            }

            .total-row:last-child {
                border-bottom: none;
                font-weight: bold;
                font-size: 1.1rem;
            }

            /* Pricing breakdown styles */
            .pricing-breakdown {
                background: #fff;
                border-radius: 8px;
                padding: 20px;
                margin-top: 20px;
                border: 1px solid #eaeaea;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            }

            .pricing-breakdown h3 {
                color: #a72036;
                margin-bottom: 15px;
                padding-bottom: 10px;
                border-bottom: 2px solid #a72036;
            }

            .item-pricing {
                margin-bottom: 20px;
                padding: 15px;
                background: #f9f9f9;
                border-radius: 6px;
                border-left: 4px solid #a72036;
            }

            .item-pricing h4 {
                color: #303038;
                margin-bottom: 10px;
                font-size: 1.1rem;
            }

            .pricing-detail {
                display: flex;
                justify-content: space-between;
                padding: 5px 0;
                font-size: 0.9rem;
            }

            .pricing-detail.total {
                font-weight: bold;
                border-top: 1px solid #ddd;
                margin-top: 10px;
                padding-top: 10px;
                font-size: 1rem;
            }

            .payment-schedule {
                background: #e8f5e8;
                border-radius: 8px;
                padding: 20px;
                margin-top: 20px;
                border: 1px solid #4caf50;
            }

            .payment-schedule h3 {
                color: #4caf50;
                margin-bottom: 15px;
            }

            .payment-item {
                display: flex;
                justify-content: space-between;
                padding: 8px 0;
                border-bottom: 1px solid #d4edda;
            }

            .payment-item:last-child {
                border-bottom: none;
                font-weight: bold;
            }

            .calculate-btn {
                background: #4caf50;
                color: white;
                border: none;
                padding: 12px 20px;
                border-radius: 6px;
                font-size: 16px;
                cursor: pointer;
                margin-top: 15px;
                display: inline-flex;
                align-items: center;
                gap: 8px;
                transition: all 0.3s;
            }

            .calculate-btn:hover {
                background: #3e8e41;
                transform: translateY(-2px);
            }

            .export-btn {
                background: #4caf50;
                color: white;
                border: none;
                padding: 12px 20px;
                border-radius: 6px;
                font-size: 16px;
                cursor: pointer;
                margin-top: 20px;
                display: inline-flex;
                align-items: center;
                gap: 8px;
            }

            .export-btn:hover {
                background: #3e8e41;
            }

            .curtain-profile-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                gap: 15px;
                margin-top: 10px;
            }

            .curtain-profile-card {
                background: white;
                border: 1px solid #e0e0e0;
                border-radius: 8px;
                padding: 20px;
                transition: all 0.3s;
                cursor: pointer;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            }

            .curtain-profile-card:hover {
                border-color: #a72036;
                transform: translateY(-3px);
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            }

            .curtain-profile-card.selected {
                border: 2px solid #a72036;
                background: rgba(167, 32, 54, 0.03);
            }

            .curtain-profile-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
                padding-bottom: 10px;
                border-bottom: 1px solid #eee;
            }

            .curtain-profile-brand {
                font-weight: 600;
                color: #303038;
            }

            .curtain-profile-code {
                background: #f0f0f0;
                padding: 3px 8px;
                border-radius: 4px;
                font-size: 0.85rem;
                font-family: monospace;
            }

            .curtain-profile-name {
                color: #a72036;
                font-weight: 600;
                margin-bottom: 8px;
            }

            .curtain-profile-price {
                font-weight: 600;
                color: #303038;
                text-align: center;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px dashed #ddd;
            }

            .curtain-wall-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                gap: 20px;
                margin-top: 20px;
            }

            /** {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }*/

            :root {
                --cocoon-primary: #a72036;
                --cocoon-dark: #303038;
                --cocoon-light: #f9bc77;
                --cocoon-white: #ffffff;
                --cocoon-light-bg: #f8f8f8;
            }

            body {
                background-color: var(--cocoon-light-bg);
                color: var(--cocoon-dark);
                font-family: "TacticSans-Reg", sans-serif;
                line-height: 1.6;
            }

            h1,
            h2,
            h3,
            h4,
            h5,
            h6,
            .btn {
                font-family: "TacticSans-Reg", sans-serif;
                font-weight: 600;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 20px;
            }

            /* Header */
            .brand-header {
                background-color: var(--cocoon-white);
                padding: 15px 0;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            }

            .brand-container {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .logo {
                width: 200px;
                height: auto;
            }

            .logo-main {
                font-size: 2.5rem;
                font-weight: 700;
                color: var(--cocoon-primary);
                letter-spacing: 1px;
            }

            .logo-sub {
                font-size: 0.9rem;
                color: var(--cocoon-dark);
                text-transform: uppercase;
                letter-spacing: 2px;
                margin-top: -5px;
            }

            .tagline {
                font-style: italic;
                color: var(--cocoon-dark);
                font-size: 1.1rem;
                text-align: right;
            }

            /* Hero Section */
            .hero {
                background: linear-gradient(
                        rgba(48, 48, 56, 0.85),
                        rgba(48, 48, 56, 0.85)
                    ),
                    url("https://images.unsplash.com/photo-1560448204-e02f11c3d0e2?ixlib=rb-4.0.3&auto=format&fit=crop&w=1920&q=80")
                        center/cover no-repeat;
                color: var(--cocoon-white);
                text-align: center;
                padding: 60px 20px;
                margin-bottom: 40px;
            }

            .hero h1 {
                font-size: 2.8rem;
                margin-bottom: 15px;
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .hero p {
                font-size: 1.2rem;
                max-width: 700px;
                margin: 0 auto 30px;
                opacity: 0.9;
            }

            /* Form Container */
            .form-container {
                background: var(--cocoon-white);
                border-radius: 10px;
                box-shadow: 0 5px 25px rgba(0, 0, 0, 0.08);
                overflow: hidden;
                margin-bottom: 60px;
                border-top: 4px solid var(--cocoon-primary);
            }

            /* Progress Bar */
            .progress-bar {
                display: flex;
                background: var(--cocoon-light-bg);
                padding: 0;
            }

            .progress-step {
                flex: 1;
                text-align: center;
                padding: 18px 10px;
                font-weight: 500;
                color: var(--cocoon-dark);
                position: relative;
                font-size: 0.9rem;
                transition: all 0.3s;
            }

            .progress-step:not(:last-child)::after {
                content: "";
                position: absolute;
                top: 50%;
                right: 0;
                width: 0;
                height: 0;
                border-top: 10px solid transparent;
                border-bottom: 10px solid transparent;
                border-left: 10px solid #ddd;
                transform: translateY(-50%);
            }

            .progress-step.active {
                background-color: var(--cocoon-primary);
                color: var(--cocoon-white);
            }

            /* Form Content */
            .form-content {
                padding: 40px;
            }

            .form-section {
                display: none;
            }

            .form-section.active {
                display: block;
                animation: fadeIn 0.5s ease;
            }

            @keyframes fadeIn {
                from {
                    opacity: 0;
                    transform: translateY(20px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            .section-title {
                margin-bottom: 30px;
                padding-bottom: 15px;
                border-bottom: 2px solid var(--cocoon-light);
                color: var(--cocoon-primary);
                font-size: 1.8rem;
                position: relative;
            }

            .section-title::after {
                content: "";
                position: absolute;
                bottom: -2px;
                left: 0;
                width: 100px;
                height: 2px;
                background: var(--cocoon-primary);
            }

            /* Form Elements */
            .form-group {
                margin-bottom: 25px;
            }

            .form-group label {
                display: block;
                margin-bottom: 8px;
                font-weight: 600;
                color: var(--cocoon-dark);
                font-size: 0.95rem;
            }

            .input-group {
                display: flex;
                gap: 15px;
                margin-bottom: 15px;
            }

            .input-group .form-control {
                flex: 1;
            }

            /* Compact Form Layout */
            .compact-form-grid {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }

            .form-row {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 12px;
                align-items: end;
            }

            /* Special handling for dimension fields */
            .form-row.dimensions {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            }

            .form-group.compact {
                margin-bottom: 0;
            }

            .form-group.compact label {
                margin-bottom: 4px;
                font-size: 0.85rem;
            }

            .form-group.compact .form-control {
                padding: 10px 12px;
                font-size: 14px;
            }

            .form-group.compact.full-width {
                grid-column: 1 / -1;
            }

            .radio-group.compact,
            .checkbox-group.compact {
                display: flex;
                gap: 12px;
                margin-top: 4px;
            }

            .radio-group.compact .radio-item,
            .checkbox-group.compact .checkbox-item {
                display: flex;
                align-items: center;
                gap: 6px;
                font-size: 0.85rem;
            }

            .radio-group.compact input,
            .checkbox-group.compact input {
                width: 16px;
                height: 16px;
            }

            .form-control {
                width: 70%;
                padding: 14px 15px;
                border: 2px solid #e0e0e0;
                border-radius: 6px;
                font-size: 16px;
                transition: all 0.3s;
                font-family: "TacticSans-Reg", sans-serif;
            }

            .form-control:focus {
                border-color: var(--cocoon-primary);
                outline: none;
                box-shadow: 0 0 0 3px rgba(167, 32, 54, 0.2);
            }

            select.form-control {
                appearance: none;
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%23303038' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10z'/%3E%3Csvg%3E");
                background-repeat: no-repeat;
                background-position: right 15px center;
                padding-right: 40px;
            }

            .checkbox-group,
            .radio-group,
            .leaves-group {
                display: flex;
                flex-wrap: wrap;
                gap: 15px;
                margin-top: 8px;
            }

            .checkbox-item,
            .radio-item,
            .leaf-item {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .leaf-item {
                flex-direction: column;
                padding: 12px 15px;
                border: 2px solid #e0e0e0;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.3s;
                min-width: 90px;
                text-align: center;
                background: var(--cocoon-white);
            }

            .leaf-item:hover {
                border-color: var(--cocoon-primary);
            }

            .leaf-item.selected {
                border-color: var(--cocoon-primary);
                background: rgba(167, 32, 54, 0.05);
            }

            .leaf-icon {
                font-size: 26px;
                margin-bottom: 5px;
                color: var(--cocoon-primary);
            }

            .checkbox-item input,
            .radio-item input {
                width: 18px;
                height: 18px;
                accent-color: var(--cocoon-primary);
            }

            /* Buttons */
            .btn {
                padding: 14px 30px;
                border: none;
                border-radius: 6px;
                font-size: 16px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                font-family: "TacticSans-Reg", sans-serif;
            }

            .btn-primary {
                background: var(--cocoon-primary);
                color: var(--cocoon-white);
            }

            .btn-primary:hover {
                background: #8a1a2c;
                transform: translateY(-2px);
                box-shadow: 0 5px 15px rgba(167, 32, 54, 0.3);
            }

            .btn-secondary {
                background: #f0f0f0;
                color: var(--cocoon-dark);
            }

            .btn-secondary:hover {
                background: #e0e0e0;
            }

            .btn-group {
                display: flex;
                gap: 15px;
                margin-top: 30px;
                justify-content: space-between;
            }

            /* Item Cards */
            .item-card {
                background: var(--cocoon-light-bg);
                border-radius: 8px;
                padding: 20px;
                margin-bottom: 20px;
                border: 1px solid #eaeaea;
                position: relative;
                transition: all 0.3s;
            }

            .item-card:hover {
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            }

            .item-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
            }

            .item-title {
                font-size: 18px;
                font-weight: 600;
                color: var(--cocoon-primary);
            }

            .item-id {
                font-size: 13px;
                color: var(--cocoon-dark);
                background: rgba(48, 48, 56, 0.1);
                padding: 4px 10px;
                border-radius: 12px;
            }

            .remove-btn {
                background: var(--cocoon-primary);
                color: white;
                border: none;
                width: 30px;
                height: 30px;
                border-radius: 50%;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.3s;
            }

            .remove-btn:hover {
                transform: rotate(90deg);
            }

            /* Recommendation Box */
            .recommendation {
                background: rgba(249, 188, 119, 0.1);
                border-left: 4px solid var(--cocoon-light);
                padding: 15px;
                border-radius: 0 8px 8px 0;
                margin: 20px 0;
            }

            .recommendation h4 {
                color: var(--cocoon-primary);
                margin-bottom: 10px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .recommendation h4 i {
                color: var(--cocoon-light);
            }

            .recommendation p {
                margin-bottom: 5px;
                line-height: 1.7;
            }

            /* System Options */
            .system-options {
                display: flex;
                flex-wrap: wrap;
                gap: 15px;
                margin-top: 15px;
            }

            .system-option {
                flex: 1;
                min-width: 200px;
                background: var(--cocoon-white);
                border: 1px solid #e0e0e0;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
                cursor: pointer;
                transition: all 0.3s;
            }

            .system-option:hover {
                border-color: var(--cocoon-primary);
                transform: translateY(-3px);
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            }

            .system-option.selected {
                border-color: var(--cocoon-primary);
                background: rgba(167, 32, 54, 0.03);
            }

            .system-option h5 {
                color: var(--cocoon-primary);
                margin-bottom: 10px;
            }

            .system-option p {
                font-size: 14px;
                color: var(--cocoon-dark);
            }

            .system-image {
                width: 100%;
                height: 130px;
                object-fit: cover;
                margin-bottom: 15px;
                border-radius: 4px;
                border: 1px solid #eee;
            }

            /* Dimension Note */
            .dimension-note {
                background: rgba(167, 32, 54, 0.05);
                border-left: 4px solid var(--cocoon-primary);
                padding: 12px 15px;
                border-radius: 0 6px 6px 0;
                margin-bottom: 20px;
                font-size: 14px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .dimension-note i {
                color: var(--cocoon-primary);
                font-size: 18px;
                min-width: 24px;
            }

            /* Summary Cards */
            .summary-card {
                background: var(--cocoon-light-bg);
                border-radius: 8px;
                padding: 25px;
                margin-bottom: 25px;
                border: 1px solid #eaeaea;
            }

            .summary-card h3 {
                color: var(--cocoon-primary);
                margin-bottom: 20px;
                padding-bottom: 10px;
                border-bottom: 2px solid var(--cocoon-light);
            }

            .summary-item {
                display: flex;
                justify-content: space-between;
                padding: 12px 0;
                border-bottom: 1px solid #eee;
            }

            .summary-item:last-child {
                border-bottom: none;
            }

            .summary-label {
                font-weight: 600;
                color: var(--cocoon-dark);
            }

            .summary-value {
                color: var(--cocoon-primary);
                font-weight: 500;
                text-align: right;
            }

            /* Success Message */
            .success-message {
                text-align: center;
                padding: 40px 20px;
                display: none;
            }

            .success-message.active {
                display: block;
            }

            .success-icon {
                font-size: 80px;
                color: #4caf50;
                margin-bottom: 20px;
            }

            .success-message h2 {
                color: var(--cocoon-primary);
                margin-bottom: 20px;
            }

            .quote-id {
                background: var(--cocoon-primary);
                color: white;
                padding: 12px 25px;
                border-radius: 30px;
                font-size: 1.2rem;
                display: inline-block;
                margin-top: 15px;
                font-family: "TacticSans-Reg", sans-serif;
            }

            /* Footer */
            .brand-footer {
                background: var(--cocoon-dark);
                color: var(--cocoon-white);
                padding: 40px 0;
                text-align: center;
                margin-top: 40px;
            }

            .footer-logo {
                font-size: 2rem;
                font-weight: 700;
                color: var(--cocoon-white);
                margin-bottom: 10px;
            }

            .footer-tagline {
                font-size: 1.2rem;
                margin-bottom: 20px;
                opacity: 0.9;
            }

            .contact-info {
                display: flex;
                justify-content: center;
                gap: 30px;
                margin-top: 20px;
                flex-wrap: wrap;
            }

            .contact-item {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            /* Responsive Design */
            @media (max-width: 768px) {
                .input-group {
                    flex-direction: column;
                    gap: 10px;
                }

                .btn-group {
                    flex-direction: column;
                }

                .system-options {
                    flex-direction: column;
                }

                .leaves-group {
                    flex-direction: column;
                }

                .leaf-item {
                    width: 100%;
                }

                .contact-info {
                    flex-direction: column;
                    gap: 15px;
                }

                .hero h1 {
                    font-size: 2.2rem;
                }

                .form-content {
                    padding: 25px;
                }

                .brand-container {
                    flex-direction: column;
                    text-align: center;
                    gap: 15px;
                }

                .tagline {
                    text-align: center;
                }
            }

            /* Cocoon Brand Elements */
            .cocoon-divider {
                height: 4px;
                background: linear-gradient(
                    to right,
                    var(--cocoon-primary),
                    var(--cocoon-light)
                );
                margin: 25px 0;
                border-radius: 2px;
            }

            .brand-highlight {
                color: var(--cocoon-primary);
            }
            .blocked_text {
                visibility: hidden;
            }
            #curtainWallDetails {
                margin-top: 15px;
                display: flex;
                flex-wrap: wrap;
                gap: 15px;
            }

            #curtainWallDetails label {
                flex: 1 1 45%;
                display: flex;
                flex-direction: column;
                font-size: 14px;
                color: #444;
            }

            #curtainWallDetails input[readonly] {
                margin-top: 6px;
                padding: 10px 12px;
                border: 1px solid #ddd;
                border-radius: 8px;
                background: #f3f3f3;
                color: #333;
                font-size: 14px;
                width: 100%;
                box-sizing: border-box;
            }

            .profile-brand-select {
                display: inline-block;
                padding: 6px 8px;
                border-radius: 6px;
                border: 1px solid #ddd;
                font-size: 14px;
                margin-bottom: 8px;
                background: white;
            }

            /* New styles for curtain wall profile selection */
            .curtain-profile-container {
                margin-top: 20px;
                padding: 15px;
                background: #f9f9f9;
                border-radius: 8px;
                border: 1px solid #eee;
            }

            .curtain-brand-filter {
                margin-bottom: 15px;
            }

            .profile-selected-badge {
                background: #4caf50;
                color: white;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 12px;
                margin-top: 10px;
                display: inline-flex;
                align-items: center;
                gap: 4px;
            }

            /* Save Dialog Modal Styles */
            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                display: none;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            }

            .modal-overlay.active {
                display: flex;
            }

            .modal-content {
                background: white;
                border-radius: 12px;
                padding: 30px;
                max-width: 500px;
                width: 90%;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                animation: modalSlideIn 0.3s ease;
            }

            @keyframes modalSlideIn {
                from {
                    opacity: 0;
                    transform: translateY(-50px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            .modal-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
                padding-bottom: 15px;
                border-bottom: 2px solid var(--cocoon-light);
            }

            .modal-title {
                color: var(--cocoon-primary);
                font-size: 1.5rem;
                font-weight: 600;
            }

            .modal-close {
                background: none;
                border: none;
                font-size: 1.5rem;
                color: #999;
                cursor: pointer;
                padding: 5px;
                border-radius: 50%;
                width: 35px;
                height: 35px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .modal-close:hover {
                background: #f0f0f0;
                color: var(--cocoon-primary);
            }

            .modal-body {
                margin-bottom: 25px;
            }

            .modal-footer {
                display: flex;
                gap: 15px;
                justify-content: flex-end;
            }

            .success-notification {
                position: fixed;
                top: 20px;
                right: 20px;
                background: #4caf50;
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
                z-index: 1001;
                display: none;
                animation: slideInRight 0.3s ease;
            }

            .success-notification.active {
                display: block;
            }

            @keyframes slideInRight {
                from {
                    opacity: 0;
                    transform: translateX(100px);
                }
                to {
                    opacity: 1;
                    transform: translateX(0);
                }
            }
        </style>
    </head>
    <body id="body">
        <!-- Brand Header -->
        <header class="brand-header">
            <div class="container brand-container">
                <div class="logo">
                    <img
                        alt="Cocoon Logo"
                        class="logo"
                        src="https://img1.wsimg.com/isteam/ip/b11b2784-66bc-4ac4-9b05-6ba6d416d22d/Untitled%20design%20(1).jpg"
                    />
                </div>
                <div
                    class="nav-links"
                    style="display: flex; gap: 20px; align-items: center"
                >
                    <a
                        href="dashboard.html"
                        style="
                            color: var(--cocoon-primary);
                            text-decoration: none;
                            font-weight: 600;
                        "
                        ><i class="fas fa-chart-line"></i> Dashboard</a
                    >
                    <a
                        href="profile-manager.html"
                        style="
                            color: var(--cocoon-primary);
                            text-decoration: none;
                            font-weight: 600;
                        "
                        ><i class="fas fa-database"></i> Profile Import</a
                    >
                </div>
                <div class="tagline">The Quality You Deserve</div>
            </div>
        </header>
        <!-- Hero Section -->
        <div
            id="blockedText"
            class="blocked_text"
        >
            <p>Account not approved, yet!</p>
        </div>
        <section
            class="hero"
            id="heroSection"
        >
            <div class="container">
                <h1>Quote Cocoon Alumil aluminium works in minutes!</h1>
                <p>
                    Complete the form below to receive a customized quote for
                    your project
                </p>
            </div>
        </section>
        <!-- Form Container -->
        <div
            class="container"
            id="mainContainer"
        >
            <div
                class="form-container"
                id="form-container"
            >
                <div class="progress-bar">
                    <div class="progress-step active">1. Project Type</div>
                    <div class="progress-step">2. Items</div>
                    <div class="progress-step">3. Contact Info</div>
                    <div class="progress-step">4. Summary</div>
                </div>
                <div class="form-content">
                    <!-- Step 1: Project Type -->
                    <div
                        class="form-section active"
                        id="step1"
                    >
                        <h2 class="section-title">Select Project Type</h2>
                        <div class="form-group">
                            <div class="radio-group">
                                <div class="radio-item">
                                    <input
                                        checked=""
                                        id="commercial"
                                        name="projectType"
                                        type="radio"
                                        value="commercial"
                                    />
                                    <label for="commercial">Commercial</label>
                                </div>
                                <div class="radio-item">
                                    <input
                                        id="villa"
                                        name="projectType"
                                        type="radio"
                                        value="villa"
                                    />
                                    <label for="villa">Villa</label>
                                </div>
                                <div class="radio-item">
                                    <input
                                        id="apartment"
                                        name="projectType"
                                        type="radio"
                                        value="apartment"
                                    />
                                    <label for="apartment">Apartment</label>
                                </div>
                            </div>
                        </div>
                        <div class="btn-group">
                            <div></div>
                            <button
                                class="btn btn-primary"
                                onclick="nextStep(2)"
                            >
                                Next <i class="fas fa-arrow-right"></i>
                            </button>
                        </div>
                    </div>
                    <!-- Step 2: Items -->
                    <div
                        class="form-section"
                        id="step2"
                    >
                        <h2 class="section-title">Add Items</h2>
                        <p>
                            Each item will have a unique ID for tracking
                            purposes
                        </p>
                        <div id="items-container">
                            <!-- Items will be added here dynamically -->
                        </div>
                        <button
                            class="btn btn-secondary"
                            id="add-item-btn"
                            style="width: 100%; margin-bottom: 20px"
                        >
                            <i class="fas fa-plus"></i> Add Another Item
                        </button>
                        <div class="btn-group">
                            <button
                                class="btn btn-secondary"
                                onclick="prevStep(1)"
                            >
                                <i class="fas fa-arrow-left"></i> Back
                            </button>
                            <button
                                class="btn btn-primary"
                                onclick="nextStep(3)"
                            >
                                Next <i class="fas fa-arrow-right"></i>
                            </button>
                        </div>
                    </div>
                    <!-- Step 3: Contact Info -->
                    <div
                        class="form-section"
                        id="step3"
                    >
                        <h2 class="section-title">Contact Information</h2>
                        <div class="form-row">
                            <div class="form-col">
                                <div class="form-group">
                                    <label>Full Name</label>
                                    <input
                                        class="form-control"
                                        id="contact-name"
                                        placeholder="John Doe"
                                        required=""
                                        type="text"
                                    />
                                </div>
                            </div>
                            <div class="form-col">
                                <div class="form-group">
                                    <label>Phone Number</label>
                                    <input
                                        class="form-control"
                                        id="contact-phone"
                                        placeholder="+966 50 123 4567"
                                        required=""
                                        type="tel"
                                    />
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Email Address</label>
                            <input
                                class="form-control"
                                id="contact-email"
                                placeholder="your.email@example.com"
                                required=""
                                type="email"
                            />
                        </div>
                        <div class="form-group">
                            <label>Preferred Contact Method</label>
                            <div class="radio-group">
                                <div class="radio-item">
                                    <input
                                        checked=""
                                        id="phone"
                                        name="contactMethod"
                                        type="radio"
                                        value="phone"
                                    />
                                    <label for="phone">Phone Call</label>
                                </div>
                                <div class="radio-item">
                                    <input
                                        id="email"
                                        name="contactMethod"
                                        type="radio"
                                        value="email"
                                    />
                                    <label for="email">Email</label>
                                </div>
                                <div class="radio-item">
                                    <input
                                        id="whatsapp"
                                        name="contactMethod"
                                        type="radio"
                                        value="whatsapp"
                                    />
                                    <label for="whatsapp">WhatsApp</label>
                                </div>
                                <div class="radio-item">
                                    <input
                                        id="visit"
                                        name="contactMethod"
                                        type="radio"
                                        value="visit"
                                    />
                                    <label for="visit">Site Visit</label>
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Project Location</label>
                            <input
                                class="form-control"
                                id="contact-location"
                                placeholder="City, District"
                                required=""
                                type="text"
                            />
                        </div>
                        <div class="form-group">
                            <label>Additional Notes</label>
                            <textarea
                                class="form-control"
                                id="contact-notes"
                                placeholder="Any special requirements or notes..."
                                rows="4"
                            ></textarea>
                        </div>
                        <div class="btn-group">
                            <button
                                class="btn btn-secondary"
                                onclick="prevStep(2)"
                            >
                                <i class="fas fa-arrow-left"></i> Back
                            </button>
                            <button
                                class="btn btn-primary"
                                onclick="nextStep(4)"
                            >
                                Next <i class="fas fa-arrow-right"></i>
                            </button>
                        </div>
                    </div>
                    <!-- Step 4: Summary -->
                    <div
                        class="form-section"
                        id="step4"
                    >
                        <h2 class="section-title">
                            Summary &amp; Quote Request
                        </h2>
                        <div class="summary-card">
                            <h3>Project Details</h3>
                            <div class="summary-item">
                                <div class="summary-label">Project Type:</div>
                                <div
                                    class="summary-value"
                                    id="summary-project-type"
                                >
                                    Villa
                                </div>
                            </div>
                            <div class="summary-item">
                                <div class="summary-label">Total Items:</div>
                                <div
                                    class="summary-value"
                                    id="summary-total-items"
                                >
                                    0
                                </div>
                            </div>
                            <div class="summary-item">
                                <div class="summary-label">
                                    Preferred Contact:
                                </div>
                                <div
                                    class="summary-value"
                                    id="summary-contact-method"
                                >
                                    WhatsApp
                                </div>
                            </div>
                        </div>
                        <div
                            class="summary-card"
                            id="summary-items"
                        >
                            <h3>Selected Systems</h3>
                            <!-- Items will be added here dynamically -->
                        </div>
                        <!-- Calculate Pricing Button -->
                        <button
                            class="calculate-btn"
                            onclick="calculatePricing()"
                        >
                            <i class="fas fa-calculator"></i> Calculate Pricing
                        </button>

                        <!-- Pricing Breakdown Section -->
                        <div
                            class="pricing-breakdown"
                            id="pricing-breakdown"
                            style="display: none"
                        >
                            <h3>Detailed Pricing Breakdown</h3>
                            <div id="pricing-items">
                                <!-- Individual item pricing will be added here -->
                            </div>

                            <!-- Project Totals -->
                            <div class="project-totals">
                                <h3>Project Totals</h3>
                                <div class="total-row">
                                    <span>Total Area (m):</span>
                                    <span id="total-area">0 m</span>
                                </div>
                                <div class="total-row">
                                    <span>Total Before Profit:</span>
                                    <span id="total-before-profit">0 EGP</span>
                                </div>
                                <div class="total-row">
                                    <span>Total Profit:</span>
                                    <span id="total-profit">0 EGP</span>
                                </div>
                                <div class="total-row">
                                    <span>Average Profit Rate:</span>
                                    <span id="average-profit-rate">0%</span>
                                </div>
                                <div class="total-row">
                                    <span>Price per m:</span>
                                    <span id="price-per-m2">0 EGP/m</span>
                                </div>
                                <div class="total-row">
                                    <span>Total Project Value:</span>
                                    <span id="total-project-value">0 EGP</span>
                                </div>
                            </div>

                            <!-- Payment Schedule -->
                            <div class="payment-schedule">
                                <h3>Payment Schedule</h3>
                                <div class="payment-item">
                                    <span>Down Payment (80%):</span>
                                    <span id="down-payment">0 EGP</span>
                                </div>
                                <div class="payment-item">
                                    <span>Supply Payment (10%):</span>
                                    <span id="supply-payment">0 EGP</span>
                                </div>
                                <div class="payment-item">
                                    <span>Completion Payment (10%):</span>
                                    <span id="completion-payment">0 EGP</span>
                                </div>
                            </div>
                        </div>
                        <div
                            class="recommendation"
                            id="final-recommendation"
                        >
                            <h4>
                                <i class="fas fa-info-circle"></i> Final
                                Recommendation
                            </h4>
                            <p id="recommendation-text">
                                Based on your project details, we'll provide
                                recommendations for the best systems.
                            </p>
                        </div>
                        <div class="btn-group">
                            <button
                                class="btn btn-secondary"
                                onclick="prevStep(3)"
                            >
                                <i class="fas fa-arrow-left"></i> Back
                            </button>
                            <button
                                class="btn btn-primary"
                                id="save-btn"
                                onclick="showSaveDialog()"
                            >
                                <i class="fas fa-save"></i> Save Quote
                            </button>
                            <button
                                class="btn btn-secondary"
                                onclick="openQuotesHistory()"
                                style="margin-left: 10px"
                            >
                                <i class="fas fa-history"></i> View Saved Quotes
                            </button>
                        </div>
                    </div>
                    <!-- Success Message -->
                    <div
                        class="form-section"
                        id="success"
                    >
                        <div class="success-message">
                            <div class="success-icon">
                                <i class="fas fa-check-circle"></i>
                            </div>
                            <h2>Thank You!</h2>
                            <p
                                style="
                                    font-size: 1.2rem;
                                    max-width: 600px;
                                    margin: 0 auto 25px;
                                "
                            >
                                Your quote request has been submitted
                                successfully. Our team will contact you within
                                24 hours to discuss your project details.
                            </p>
                            <div class="quote-id">
                                Quote ID:
                                <span id="quote-id-display">QU-12345</span>
                            </div>
                            <p style="margin-top: 20px; font-style: italic">
                                Each item in your quote has a unique ID for
                                tracking purposes.
                            </p>
                            <button
                                class="btn btn-primary"
                                onclick="resetForm()"
                                style="margin-top: 30px"
                            >
                                <i class="fas fa-redo"></i> Submit Another
                                Request
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Brand Footer -->
        <footer class="brand-footer">
            <div class="container">
                <div class="footer-logo">COCOON</div>
                <div class="footer-tagline">The Quality You Deserve</div>
                <div class="cocoon-divider"></div>
                <div class="contact-info">
                    <div class="contact-item">
                        <i class="fas fa-phone"></i>
                        <span>+20 11 51717149</span>
                    </div>
                    <div class="contact-item">
                        <i class="fas fa-envelope"></i>
                        <span>sales.department@cocoonaluminum.com</span>
                    </div>
                    <div class="contact-item">
                        <i class="fas fa-map-marker-alt"></i>
                        <span
                            >61 Seventh neighborhood, Fourth District, El-Shaikh
                            Zayed, Giza</span
                        >
                    </div>
                </div>
            </div>
        </footer>

        <!-- Save Quote Dialog -->
        <div
            class="modal-overlay"
            id="saveModal"
        >
            <div class="modal-content">
                <div class="modal-header">
                    <h3 class="modal-title">Save Quote</h3>
                    <button
                        class="modal-close"
                        onclick="closeSaveDialog()"
                    >
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="quoteName">Quote Name</label>
                        <input
                            type="text"
                            id="quoteName"
                            class="form-control"
                            placeholder="Enter a name for this quote..."
                            maxlength="50"
                        />
                        <small style="color: #666; font-size: 0.85rem"
                            >This will help you identify the quote later</small
                        >
                    </div>
                    <div
                        class="form-group"
                        style="margin-top: 20px"
                    >
                        <label for="quoteDescription"
                            >Description (Optional)</label
                        >
                        <textarea
                            id="quoteDescription"
                            class="form-control"
                            rows="3"
                            placeholder="Add any notes or description for this quote..."
                            maxlength="200"
                        ></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button
                        class="btn btn-secondary"
                        onclick="closeSaveDialog()"
                    >
                        Cancel
                    </button>
                    <button
                        class="btn btn-primary"
                        onclick="confirmSaveQuote()"
                    >
                        <i class="fas fa-save"></i> Save Quote
                    </button>
                </div>
            </div>
        </div>

        <!-- Success Notification -->
        <div
            class="success-notification"
            id="successNotification"
        >
            <i
                class="fas fa-check-circle"
                style="margin-right: 10px"
            ></i>
            <span id="notificationText">Quote saved successfully!</span>
        </div>

        <script>
            // JavaScript code with requested modifications
            let currentStep = 1;
            let itemCount = 0;
            let items = [];
            let quoteId = null;
            let profiles = [];
            const WEBHOOK_URL =
                "https://rashadzzz.app.n8n.cloud/webhook/c0ff5a1b-87dc-4e59-bb35-af0210525bbe";

            const userRole = localStorage.getItem("role");
            console.log("user role found with this role:", userRole);
            async function blockNotAprovedUsers() {
                //if (userRole === "pending") {
                console.log("blocking the UI from asss");
                const heroSection = document.getElementById("heroSection");
                const mainContainer = document.getElementById("mainContainer");
                //mainContainer.style.setProperty("display: none;");
                mainContainer.style.visibility = "hidden";
                heroSection.style.visibility = "hidden";
                //const blockedText = `<p>Account not approved, yet!</p>`;
                //mainContainer.innerHTML(blockedText);
                //}
                const blockedText = document.getElementById("blockedText");
                blockedText.style.visibility = "visible";
            }

            // Initialize with one item
            document.addEventListener("DOMContentLoaded", async function () {
                // Initialize Firebase Auth
                try {
                    await FirebaseAuth.initializeAuth();
                    console.log("Firebase Auth initialized");

                    // Check if user is pending and block access if needed
                    if (userRole === "pending") blockNotAprovedUsers();
                    const isBlocked =
                        await SecurityManager.checkAndBlockPendingUser();
                    if (isBlocked) {
                        console.log(
                            "User is pending approval - blocking access to quote generator"
                        );
                        return; // Stop further initialization
                    }
                } catch (error) {
                    console.error("Error initializing Firebase Auth:", error);
                }

                addNewItem();
                await loadProfiles();

                // Add event listener for add item button
                document
                    .getElementById("add-item-btn")
                    .addEventListener("click", function (e) {
                        e.preventDefault();
                        addNewItem();
                    });

                // Check if we need to load a specific quote
                const loadQuoteId = localStorage.getItem("loadQuoteId");
                if (loadQuoteId) {
                    localStorage.removeItem("loadQuoteId");
                    // Wait for profiles to load before attempting to load the quote
                    waitForProfilesAndLoadQuote(loadQuoteId);
                }
            });

            // Function to wait for profiles to load before loading a quote
            function waitForProfilesAndLoadQuote(quoteId) {
                const maxAttempts = 20; // Maximum 10 seconds (20 * 500ms)
                let attempts = 0;

                const checkProfiles = () => {
                    attempts++;

                    if (profiles && profiles.length > 0) {
                        // Profiles are loaded, now load the quote
                        setTimeout(() => {
                            loadSavedQuote(quoteId);
                        }, 500); // Small delay to ensure UI is ready
                    } else if (attempts < maxAttempts) {
                        // Profiles not loaded yet, try again
                        setTimeout(checkProfiles, 500);
                    } else {
                        // Max attempts reached, show error
                        console.error(
                            "Profiles failed to load within timeout period"
                        );
                        alert(
                            "Error loading quote: Profile data not available. Please refresh the page and try again."
                        );
                    }
                };

                checkProfiles();
            }

            // Load profiles from Firebase
            async function loadProfiles() {
                try {
                    console.log("Loading profiles from Firebase...");

                    // Check if Firebase is available
                    if (!FirebaseDB || !FirebaseDB.Profiles) {
                        console.warn(
                            "Firebase not available, falling back to localStorage"
                        );
                        // Fallback to localStorage
                        const savedProfiles =
                            localStorage.getItem("cocoonProfiles");
                        if (savedProfiles) {
                            profiles = JSON.parse(savedProfiles);
                            window.cocoonProfiles = profiles;
                            console.log(
                                `Loaded ${profiles.length} profiles from localStorage fallback`
                            );
                        } else {
                            profiles = [];
                            console.log(
                                "No profiles found in localStorage fallback"
                            );
                        }
                    } else {
                        // Load from Firebase
                        profiles = await FirebaseDB.Profiles.loadProfiles();
                        window.cocoonProfiles = profiles;
                        console.log(
                            `Successfully loaded ${profiles.length} profiles from Firebase`
                        );
                    }

                    if (profiles.length === 0) {
                        console.warn(
                            "No profile data available. Please import profiles using the Profile Import page."
                        );
                    } else {
                        console.log(
                            `Successfully loaded ${profiles.length} profiles`
                        );
                    }

                    // Trigger any pending profile-dependent operations
                    if (window.profilesLoadedCallbacks) {
                        window.profilesLoadedCallbacks.forEach((callback) => {
                            try {
                                callback();
                            } catch (error) {
                                console.error(
                                    "Error in profiles loaded callback:",
                                    error
                                );
                            }
                        });
                        window.profilesLoadedCallbacks = [];
                    }

                    // Update profile options for all existing items after profiles are loaded
                    items.forEach((item) => {
                        if (item.id) {
                            updateProfileOptions(item.id);
                        }
                    });
                } catch (error) {
                    console.error(
                        "Error loading profiles from Firebase:",
                        error
                    );
                    // Fallback to localStorage
                    try {
                        const savedProfiles =
                            localStorage.getItem("cocoonProfiles");
                        if (savedProfiles) {
                            profiles = JSON.parse(savedProfiles);
                            window.cocoonProfiles = profiles;
                            console.log(
                                `Loaded ${profiles.length} profiles from localStorage fallback`
                            );
                        } else {
                            profiles = [];
                            console.log(
                                "No profiles found in localStorage fallback"
                            );
                        }
                    } catch (fallbackError) {
                        console.error(
                            "Error in localStorage fallback:",
                            fallbackError
                        );
                        profiles = [];

                        // Show user-friendly error message
                        setTimeout(() => {
                            alert(
                                "Warning: Could not load profile data from the server. Some features may not work correctly. Please check your internet connection and refresh the page."
                            );
                        }, 1000);
                    }

                    // Update profile options for all existing items after profiles are loaded (even in fallback)
                    items.forEach((item) => {
                        if (item.id) {
                            updateProfileOptions(item.id);
                        }
                    });
                }
            }

            // Add new item
            function addNewItem() {
                itemCount++;
                const itemId = `item-${itemCount}`;
                const uniqueId = generateUniqueId();

                const itemHTML = `
                <div class="item-card" id="${itemId}">
                    <div class="item-header">
                        <div>
                            <div class="item-title">Item #${itemCount}</div>
                            <div class="item-id">ID: ${uniqueId}</div>
                        </div>
                        <button class="remove-btn" onclick="removeItem('${itemId}')"><i class="fas fa-times"></i></button>
                    </div>

                    <div class="form-group">
                        <label>Item Type</label>
                        <select class="form-control item-type" onchange="updateItemType('${itemId}', this.value)">
                            <option value="">Select item type</option>
                            <option value="window">Window</option>
                            <option value="door">Door</option>
                            <option value="skylight">Skylight</option>
                            <option value="sunroom">Sunroom</option>
                            <option value="curtain_wall">Curtain Wall</option>
                        </select>
                    </div>

                    <!-- Normal fields (for windows, doors, etc.) -->
                    <div class="normal-fields">
                        <!-- Normal Item Summary with SVG - Moved to top -->
                        <div id="normalItemSummary-${itemId}" style="display:none; padding:15px; border:1px solid #ddd; border-radius:8px; background:#fafafa; margin-bottom:15px;">
                            <h4 style="margin-bottom:10px;">Item Design Preview</h4>
                            <div id="normalItemShape-${itemId}" style="text-align:center; margin-bottom:15px;"></div>
                            <div id="normalItemDetails-${itemId}"></div>
                            <div id="normalItemStats-${itemId}" style="margin-top:15px;"></div>
                        </div>

                        <!-- Compact grid layout for better UX -->
                        <div class="compact-form-grid">
                            <!-- Row 1: System Type and Quantity -->
                            <div class="form-row">
                                <div class="form-group compact">
                                    <label>System Type</label>
                                    <select class="form-control item-system" onchange="updateProfileOptions('${itemId}'); updateLeavesDropdown('${itemId}', this.value); toggleNetTypeField('${itemId}'); toggleUpperPanelTypeField('${itemId}'); regenerateItemSvg('${itemId}')">
                                        <option value="">Select system type</option>
                                        <option value="Sliding">Sliding</option>
                                        <option value="hinged">Hinged</option>
                                        <option value="folding">Folding</option>
                                        <option value="tilt">Tilt</option>
                                        <option value="tilt-turn">Tilt & Turn</option>
                                        <option value="lift-slide">Lift & Slide</option>
                                        <option value="fixed">fixed</option>
                                    </select>
                                </div>
                                <div class="form-group compact">
                                    <label>Quantity</label>
                                    <input type="number" class="form-control item-quantity" placeholder="1" min="1" step="1" value="1" onchange="regenerateItemSvg('${itemId}')">
                                </div>
                            </div>

                            <!-- Row 2: Dimensions -->
                            <div class="form-row dimensions">
                                <div class="form-group compact">
                                    <label>Width (m)</label>
                                    <input type="number" class="form-control item-width" placeholder="1.5" min="0.1" step="0.1" onchange="updateProfileOptions('${itemId}'); regenerateItemSvg('${itemId}')">
                                </div>
                                <div class="form-group compact">
                                    <label>Height (m)</label>
                                    <input type="number" class="form-control item-height" placeholder="2.0" min="0.1" step="0.1" onchange="updateProfileOptions('${itemId}'); regenerateItemSvg('${itemId}')">
                                </div>
                                <div class="form-group compact">
                                    <label>Leaves</label>
                                    <select class="form-control item-leaves" id="leaves-${itemId}">
                                        <option value="2">2 Leaves</option>
                                        <option value="3">3 Leaves</option>
                                        <option value="4">4 Leaves</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Row 3: Glass and Color -->
                            <div class="form-row">
                                <div class="form-group compact">
                                    <label>Glass Type</label>
                                    <div class="radio-group compact item-glass-type">
                                        <div class="radio-item">
                                            <input type="radio" name="glassType-${itemId}" id="single-${itemId}" value="single" onchange="updateArgonCheckbox('${itemId}'); regenerateItemSvg('${itemId}')">
                                            <label for="single-${itemId}">Single</label>
                                        </div>
                                        <div class="radio-item">
                                            <input type="radio" name="glassType-${itemId}" id="double-${itemId}" value="double" checked onchange="updateArgonCheckbox('${itemId}'); regenerateItemSvg('${itemId}')">
                                            <label for="double-${itemId}">Double</label>
                                        </div>
                                    </div>
                                </div>
                                <div class="form-group compact">
                                    <label>Glass Appearance</label>
                                    <select class="form-control item-glass-appearance" onchange="regenerateItemSvg('${itemId}')">
                                        <option value="clear">Clear</option>
                                        <option value="reflective-white">Reflective - White</option>
                                        <option value="reflective-grey">Reflective - Grey</option>
                                        <option value="reflective-blue">Reflective - Blue</option>
                                        <option value="reflective-black">Reflective - Black</option>
                                        <option value="smart-film">Smart Film</option>
                                    </select>
                                </div>
                                <div class="form-group compact">
                                    <label>Color</label>
                                    <select class="form-control item-color" onchange="regenerateItemSvg('${itemId}')">
                                        <option value="">Select color</option>
                                        <option value="red">Red</option>
                                        <option value="black">Black</option>
                                        <option value="white">White</option>
                                        <option value="grey">Grey</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Row 4: Additional Options -->
                            <div class="form-row">
                                <div class="form-group compact full-width">
                                    <label>Additional Options</label>
                                    <div class="checkbox-group compact">
                                        <div class="checkbox-item">
                                            <input type="checkbox" class="item-argon" id="argon-${itemId}" value="argon" checked onchange="regenerateItemSvg('${itemId}')">
                                            <label for="argon-${itemId}">Argon Heat Isolation</label>
                                        </div>
                                        <div class="checkbox-item">
                                            <input type="checkbox" class="item-mosquito" id="mosquito-${itemId}" value="mosquito" onchange="toggleNetTypeField('${itemId}'); regenerateItemSvg('${itemId}')">
                                            <label for="mosquito-${itemId}">Mosquito Net</label>
                                        </div>
                                        <div class="checkbox-item">
                                            <input type="checkbox" class="item-arch" id="arch-${itemId}" value="arch" onchange="regenerateItemSvg('${itemId}')">
                                            <label for="arch-${itemId}">Architrave</label>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Row 5: Upper Panel Type (for hinged with 2 leaves) -->
                            <div class="form-row" id="upper-panel-type-${itemId}" style="display: none;">
                                <div class="form-group compact">
                                    <label>Upper Panel Type</label>
                                    <select class="form-control item-upper-panel-type" onchange="regenerateItemSvg('${itemId}')">
                                        <option value="hinged">Hinged</option>
                                        <option value="fixed">Fixed</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Row 6: Net Type (conditional) -->
                            <div class="form-row" id="net-type-container-${itemId}" style="display: none;">
                                <div class="form-group compact">
                                    <label>Net Type</label>
                                    <select class="form-control item-net-type" onchange="regenerateItemSvg('${itemId}')">
                                        <option value="fixed">Fixed</option>
                                        <option value="plisse">Plisse</option>
                                        <option value="panda">Panda</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <!-- Profile Selection -->
                        <div class="form-group" id="profile-selection-${itemId}" style="display: none;">
                            <label>Available Profiles</label>
                            <div class="loading-profiles" id="profile-loading-${itemId}">
                                <i class="fas fa-spinner"></i>
                                <p>Loading available profiles...</p>
                            </div>
                            <div class="profile-grid" id="profile-grid-${itemId}"></div>
                            <div class="no-profiles" id="no-profiles-${itemId}" style="display: none;">
                                <i class="fas fa-exclamation-triangle"></i>
                                <p>No profiles available for these dimensions and system type.</p>
                                <p>Please adjust dimensions or contact our specialists.</p>
                            </div>
                        </div>
                    </div>

                    <!-- Curtain Wall fields -->
                    <div class="curtain-wall-container" style="display:none;">
                        <div id="curtainWallDesigner-${itemId}">
                            <!-- Embedded Curtain Wall Designer -->
                            <div class="curtain-designer-embedded">
                                <div class="curtain-designer-header">
                                    <h3><i class="fas fa-border-all"></i> Curtain Wall Designer</h3>
                                    <p class="curtain-designer-subtitle">Design your curtain wall structure and get precise measurements</p>
                                </div>

                                <div class="curtain-app-container">
                                    <div class="curtain-control-panel">
                                        <div class="curtain-card">
                                            <h4 class="curtain-card-title"><i class="fas fa-drafting-compass"></i> Design Tools</h4>

                                            <div class="curtain-mode-selector" id="curtain-mode-selector-${itemId}">
                                                <div class="curtain-mode-btn active" data-mode="structure">
                                                    <i class="fas fa-square" style="color: #2ecc71;"></i>
                                                    <span>Structure</span>
                                                </div>
                                                <div class="curtain-mode-btn" data-mode="window">
                                                    <i class="fas fa-window-maximize" style="color: #42a5f5;"></i>
                                                    <span>Window</span>
                                                </div>
                                                <div class="curtain-mode-btn" data-mode="door">
                                                    <i class="fas fa-door-open" style="color: #ffca28;"></i>
                                                    <span>Door</span>
                                                </div>
                                            </div>

                                            <div class="curtain-panel-info" id="curtain-selected-panel-info-${itemId}">
                                                <p>No panel selected</p>
                                            </div>

                                            <div class="curtain-panel-actions">
                                                <button type="button" id="curtain-clear-selection-${itemId}" class="btn btn-secondary"><i class="fas fa-times"></i> Clear Selection</button>
                                                <button type="button" id="curtain-merge-btn-${itemId}" class="btn btn-primary"><i class="fas fa-object-group"></i> Merge Panels</button>
                                                <button type="button" id="curtain-split-btn-${itemId}" class="btn btn-secondary"><i class="fas fa-object-ungroup"></i> Split Panel</button>
                                            </div>
                                        </div>

                                        <div class="curtain-card">
                                            <h4 class="curtain-card-title"><i class="fas fa-sliders-h"></i> Setup Parameters</h4>

                                            <div class="curtain-controls">
                                                <div class="curtain-control-group">
                                                    <label for="curtain-panel-cols-${itemId}">Columns (Width)</label>
                                                    <input type="number" id="curtain-panel-cols-${itemId}" class="form-control" min="1" max="10" value="4">
                                                </div>

                                                <div class="curtain-control-group">
                                                    <label for="curtain-panel-rows-${itemId}">Rows (Height)</label>
                                                    <input type="number" id="curtain-panel-rows-${itemId}" class="form-control" min="1" max="10" value="3">
                                                </div>

                                                <div class="curtain-control-group">
                                                    <label>Wall Dimensions</label>
                                                    <div class="curtain-dimension-inputs">
                                                        <input type="number" id="curtain-wall-width-${itemId}" class="form-control" placeholder="Width (m)" value="4.0" min="1" step="0.1">
                                                        <input type="number" id="curtain-wall-height-${itemId}" class="form-control" placeholder="Height (m)" value="3.0" min="1" step="0.1">
                                                    </div>
                                                </div>



                                                <div class="curtain-control-group">
                                                    <label>Column Sizes (Width)</label>
                                                    <div class="curtain-size-inputs" id="curtain-column-sizes-${itemId}">
                                                        <!-- Column size inputs will be generated here -->
                                                    </div>
                                                </div>

                                                <div class="curtain-control-group">
                                                    <label>Row Sizes (Height)</label>
                                                    <div class="curtain-size-inputs" id="curtain-row-sizes-${itemId}">
                                                        <!-- Row size inputs will be generated here -->
                                                    </div>
                                                </div>

                                                <button type="button" id="curtain-apply-grid-${itemId}" class="btn btn-primary"><i class="fas fa-sync-alt"></i> Apply Grid</button>
                                            </div>

                                            <div class="curtain-instructions">
                                                <p><strong>How to design your curtain wall:</strong></p>
                                                <ul>
                                                    <li>Set the number of columns and rows</li>
                                                    <li>Enter exact sizes for each column and row</li>
                                                    <li>Enter your wall dimensions for accurate calculations</li>
                                                    <li>Select a tool (Structure, Window, or Door)</li>
                                                    <li>Click on panels to assign types</li>
                                                    <li>Select multiple panels to merge them</li>
                                                    <li>Everything refreshes automatically when you change dimensions</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="curtain-design-area-wrapper">
                                        <div class="curtain-design-area">
                                            <div class="curtain-panel-grid" id="curtain-panel-grid-${itemId}">
                                                <!-- Panels will be generated here -->
                                            </div>
                                        </div>
                                        <div class="curtain-merge-hint">Hold Ctrl/Cmd and click to select multiple panels</div>

                                        <div class="curtain-card curtain-calculations-panel">
                                            <h4 class="curtain-card-title"><i class="fas fa-calculator"></i> Calculations</h4>

                                            <div class="curtain-results">
                                                <div class="curtain-result-card">
                                                    <div class="curtain-result-label">Frame Meters</div>
                                                    <div class="curtain-result-value" id="curtain-frame-meters-${itemId}">0.00</div>
                                                </div>
                                                <div class="curtain-result-card">
                                                    <div class="curtain-result-label">Window/Door Meters</div>
                                                    <div class="curtain-result-value" id="curtain-window-meters-${itemId}">0.00</div>
                                                </div>
                                                <div class="curtain-result-card">
                                                    <div class="curtain-result-label">Glass Area</div>
                                                    <div class="curtain-result-value" id="curtain-glass-area-${itemId}">0.00 m</div>
                                                </div>
                                                <div class="curtain-result-card">
                                                    <div class="curtain-result-label">Corners</div>
                                                    <div class="curtain-result-value" id="curtain-corner-count-${itemId}">0</div>
                                                </div>
                                            </div>

                                            <div class="curtain-calculation-details">
                                                <h4>Calculation Details</h4>
                                                <div class="curtain-detail-item">
                                                    <span>Total Panels:</span>
                                                    <span id="curtain-panel-count-${itemId}">0</span>
                                                </div>
                                                <div class="curtain-detail-item">
                                                    <span>Windows:</span>
                                                    <span id="curtain-window-count-${itemId}">0</span>
                                                </div>
                                                <div class="curtain-detail-item">
                                                    <span>Doors:</span>
                                                    <span id="curtain-door-count-${itemId}">0</span>
                                                </div>
                                                <div class="curtain-detail-item">
                                                    <span>Shared Edges:</span>
                                                    <span id="curtain-shared-edges-${itemId}">0 m</span>
                                                </div>
                                            </div>

                                            <div class="curtain-calc-breakdown">
                                                <h4><i class="fas fa-calculator"></i> Frame Calculation Breakdown</h4>
                                                <div class="curtain-detail-item">
                                                    <span>External Perimeter:</span>
                                                    <span id="curtain-external-perimeter-${itemId}">0.00 m</span>
                                                </div>
                                                <div class="curtain-detail-item">
                                                    <span>Internal Dividers:</span>
                                                    <span id="curtain-internal-dividers-${itemId}">0.00 m</span>
                                                </div>
                                                <div class="curtain-detail-item">
                                                    <span>Total Frame Meters:</span>
                                                    <span id="curtain-total-frame-display-${itemId}">0.00 m</span>
                                                </div>
                                            </div>

                                            <div class="curtain-action-buttons">
                                                <button type="button" class="btn btn-primary" id="curtain-save-design-${itemId}"><i class="fas fa-save"></i> Save Design</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div id="curtainWallSummary-${itemId}" style="display:none; padding:15px; border:1px solid #ddd; border-radius:8px; background:#fafafa;">
                            <h4 style="margin-bottom:10px;">Curtain Wall Design</h4>
                            <div id="curtainWallShape-${itemId}" style="text-align:center; margin-bottom:15px;"></div>
                            <div id="curtainWallDetails-${itemId}"></div>
                            <div id="curtainWallStats-${itemId}" style="margin-top:15px;"></div>

                            <!-- Brand filter -->
                            <div class="curtain-brand-filter" data-item-id="${itemId}">
                                <label for="curtainBrandSelect-${itemId}">Filter by Brand:</label>
                                <select id="curtainBrandSelect-${itemId}" class="profile-brand-select" onchange="filterCurtainProfiles('${itemId}', this.value)">
                                    <option value="">All Brands</option>
                                </select>
                            </div>

                            <div class="form-group" style="margin-top:15px;">
                                <label>Quantity</label>
                                <input type="number" class="form-control curtain-quantity" min="1" step="1" value="1">
                            </div>

                            <!-- NEW: Glass type selection for curtain wall -->
                            <div class="form-group">
                                <label>Glass Type</label>
                                <div class="radio-group curtain-glass-type">
                                    <div class="radio-item">
                                        <input type="radio" name="curtainGlassType-${itemId}" id="curtainSingle-${itemId}" value="single">
                                        <label for="curtainSingle-${itemId}">Single Glass</label>
                                    </div>
                                    <div class="radio-item">
                                        <input type="radio" name="curtainGlassType-${itemId}" id="curtainDouble-${itemId}" value="double" checked>
                                        <label for="curtainDouble-${itemId}">Double Glass</label>
                                    </div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label>Curtain Wall Profile</label>
                                <div class="curtain-profile-container">
                                    <div class="loading-profiles" id="curtain-profile-loading-${itemId}">
                                        <i class="fas fa-spinner"></i>
                                        <p>Loading available profiles...</p>
                                    </div>
                                    <div class="profile-grid" id="curtain-profile-grid-${itemId}"></div>
                                    <div class="no-profiles" id="curtain-no-profiles-${itemId}" style="display: none;">
                                        <i class="fas fa-exclamation-triangle"></i>
                                        <p>No curtain wall profiles available.</p>
                                        <p>Please contact our specialists for assistance.</p>
                                    </div>
                                </div>
                            </div>

                            <button type="button" class="btn btn-secondary" onclick="editCurtainWall('${itemId}')">
                                <i class="fas fa-edit"></i> Edit Design
                            </button>
                        </div>
                    </div>
                </div>
            `;

                document
                    .getElementById("items-container")
                    .insertAdjacentHTML("beforeend", itemHTML);

                // Initialize curtain wall fields as hidden
                const curtainContainer = document.querySelector(
                    `#${itemId} .curtain-wall-container`
                );
                if (curtainContainer) {
                    curtainContainer.style.display = "none";
                }

                // Initialize normal fields as visible
                const normalFields = document.querySelector(
                    `#${itemId} .normal-fields`
                );
                if (normalFields) {
                    normalFields.style.display = "block";
                }

                items.push({
                    id: itemId,
                    uniqueId: uniqueId,
                    type: "",
                    // For normal items
                    width: "",
                    height: "",
                    leaves: 2, // Default to 2 leaves
                    system: "",
                    profile: null,
                    color: "",
                    glassType: "double",
                    glassAppearance: "clear",
                    argon: true,
                    mosquito: false,
                    arch: false,
                    netType: null,
                    quantity: 1,
                    upperPanelType: "hinged", // Default to hinged for upper panel
                    visualSvg: null, // Will store the generated SVG string for normal items
                    // For curtain wall
                    curtain: {
                        wallWidth: 0, // Added for clarity
                        wallHeight: 0, // Added for clarity
                        cols: 0, // Added for clarity
                        rows: 0, // Added for clarity
                        frameMeters: 0,
                        windowMeters: 0,
                        glassArea: 0,
                        glassType: "double", // Default to double glass
                        quantity: 1,
                        profile: null,
                        designData: null, // Raw data from designer
                        visualSvg: null, // Will store the generated SVG string
                    },
                });
            }

            // Update item type and toggle fields
            function updateItemType(itemId, type) {
                const item = items.find((item) => item.id === itemId);
                if (!item) return;

                item.type = type;
                const itemElement = document.getElementById(itemId);

                if (!itemElement) return;

                const normalFields =
                    itemElement.querySelector(".normal-fields");
                const curtainContainer = itemElement.querySelector(
                    ".curtain-wall-container"
                );
                const curtainDesigner = itemElement.querySelector(
                    `#curtainWallDesigner-${itemId}`
                );
                const curtainSummary = itemElement.querySelector(
                    `#curtainWallSummary-${itemId}`
                );

                if (type === "curtain_wall") {
                    // Hide normal fields
                    if (normalFields) normalFields.style.display = "none";

                    // Show curtain wall container and designer
                    if (curtainContainer)
                        curtainContainer.style.display = "block";
                    if (curtainDesigner)
                        curtainDesigner.style.display = "block";
                    if (curtainSummary) curtainSummary.style.display = "none";

                    // Initialize curtain wall data structure if it doesn't exist
                    if (!item.curtain) {
                        item.curtain = {
                            wallWidth: 0,
                            wallHeight: 0,
                            cols: 0,
                            rows: 0,
                            panels: [],
                            frameMeters: 0,
                            windowMeters: 0,
                            glassArea: 0,
                            quantity: 1,
                            glassType: "double", // Default to double glass
                            profile: null,
                            designData: null,
                            visualSvg: null,
                        };
                    }

                    // Load curtain wall profiles
                    loadCurtainProfiles(itemId);
                } else {
                    // Show normal fields
                    if (normalFields) normalFields.style.display = "block";

                    // Hide curtain wall container
                    if (curtainContainer)
                        curtainContainer.style.display = "none";

                    // Update profile options for normal items
                    updateProfileOptions(itemId);

                    // Update SVG and summary if dimensions are available
                    if (item.width && item.height) {
                        item.visualSvg = generateNormalItemSvg(item);
                        updateNormalItemSummary(item.id);
                    }
                }
            }

            // Load curtain wall profiles
            function loadCurtainProfiles(itemId) {
                const loadingEl = document.getElementById(
                    `curtain-profile-loading-${itemId}`
                );
                const gridEl = document.getElementById(
                    `curtain-profile-grid-${itemId}`
                );
                const noProfilesEl = document.getElementById(
                    `curtain-no-profiles-${itemId}`
                );
                const brandSelect = document.getElementById(
                    `curtainBrandSelect-${itemId}`
                );

                // Show loading state
                loadingEl.style.display = "block";
                gridEl.style.display = "none";
                noProfilesEl.style.display = "none";

                // Filter for curtain wall profiles
                const curtainProfiles = profiles.filter(
                    (p) =>
                        p.system &&
                        p.system.toLowerCase().includes("curtain wall")
                );

                // Populate brand filter
                if (brandSelect) {
                    // Get unique brands
                    const brands = [
                        ...new Set(curtainProfiles.map((p) => p.Brand)),
                    ].filter((b) => b);
                    brandSelect.innerHTML =
                        '<option value="">All Brands</option>';

                    brands.forEach((brand) => {
                        const option = document.createElement("option");
                        option.value = brand;
                        option.textContent = brand;
                        brandSelect.appendChild(option);
                    });
                }

                // Simulate loading delay
                setTimeout(() => {
                    loadingEl.style.display = "none";

                    if (curtainProfiles.length === 0) {
                        noProfilesEl.style.display = "block";
                        return;
                    }

                    // Render the profiles
                    renderCurtainProfiles(itemId, curtainProfiles);
                }, 500);
            }

            // Filter curtain wall profiles by brand
            function filterCurtainProfiles(itemId, brand) {
                const curtainProfiles = profiles.filter(
                    (p) =>
                        p.system &&
                        p.system.toLowerCase().includes("curtain wall") &&
                        (!brand || p.Brand === brand)
                );

                renderCurtainProfiles(itemId, curtainProfiles);
            }

            // Render curtain wall profiles
            function renderCurtainProfiles(itemId, profiles) {
                const gridEl = document.getElementById(
                    `curtain-profile-grid-${itemId}`
                );
                const noProfilesEl = document.getElementById(
                    `curtain-no-profiles-${itemId}`
                );

                gridEl.innerHTML = "";

                if (profiles.length === 0) {
                    noProfilesEl.style.display = "block";
                    return;
                }

                noProfilesEl.style.display = "none";

                profiles.forEach((profile) => {
                    const profileCard = document.createElement("div");
                    profileCard.className = "profile-card";
                    profileCard.onclick = () =>
                        selectCurtainProfile(itemId, profile);

                    profileCard.innerHTML = `
                    <div class="profile-header">
                        <div class="profile-brand">${
                            profile.Brand || "N/A"
                        }</div>
                        <div class="profile-code">${
                            profile.profile_code || "N/A"
                        }</div>
                    </div>
                    <div class="profile-name">${
                        profile.profile_name || "N/A"
                    }</div>
                    <div class="profile-specs">
                        <div class="spec-item">
                            <span class="spec-label">Max Height</span>
                            <span class="spec-value">${
                                profile.max_h || "N/A"
                            } m</span>
                        </div>
                        <div class="spec-item">
                            <span class="spec-label">Max Width</span>
                            <span class="spec-value">${
                                profile.max_w || "N/A"
                            } m</span>
                        </div>
                        <div class="spec-item">
                            <span class="spec-label">System</span>
                            <span class="spec-value">${
                                profile.system || "N/A"
                            }</span>
                        </div>
                        <div class="spec-item">
                            <span class="spec-label">Frame Price</span>
                            <span class="spec-value">${
                                profile.frame_price || "N/A"
                            } EGP</span>
                        </div>
                    </div>
                    <div class="profile-notice">
                        <i class="fas fa-info-circle"></i>
                        <span>Curtain wall profile suitable for various configurations</span>
                    </div>
                `;

                    gridEl.appendChild(profileCard);
                });

                gridEl.style.display = "grid";
            }

            // Select curtain wall profile
            function selectCurtainProfile(itemId, profile) {
                const item = items.find((item) => item.id === itemId);
                if (!item || item.type !== "curtain_wall") return;

                // Update item with selected profile
                item.curtain.profile = profile;

                // Update UI - mark selected card
                const profileGrid = document.getElementById(
                    `curtain-profile-grid-${itemId}`
                );
                if (!profileGrid) return;

                const profileCards =
                    profileGrid.querySelectorAll(".profile-card");

                profileCards.forEach((card) => {
                    card.classList.remove("selected");
                    const profileCodeEl = card.querySelector(".profile-code");
                    if (
                        profileCodeEl &&
                        profileCodeEl.textContent === profile.profile_code
                    ) {
                        card.classList.add("selected");

                        // Add selected badge
                        const existingBadge = card.querySelector(
                            ".profile-selected-badge"
                        );
                        if (!existingBadge) {
                            const badge = document.createElement("div");
                            badge.className = "profile-selected-badge";
                            badge.innerHTML =
                                '<i class="fas fa-check"></i> Selected';
                            card.appendChild(badge);
                        }
                    }
                });

                // Only show confirmation message if this is a user selection (not automatic loading)
                if (!window.isLoadingQuote) {
                    alert(
                        `Profile "${profile.profile_name}" selected for this curtain wall.`
                    );
                }
            }

            // Update argon checkbox state
            function updateArgonCheckbox(itemId) {
                const item = items.find((item) => item.id === itemId);
                if (!item) return;
                const itemElement = document.getElementById(itemId);
                if (!itemElement) return;

                const glassType = itemElement.querySelector(
                    ".item-glass-type input:checked"
                )?.value;
                const argonCheckbox = itemElement.querySelector(".item-argon");

                if (glassType === "double") {
                    argonCheckbox.disabled = false;
                } else {
                    argonCheckbox.checked = false;
                    argonCheckbox.disabled = true;
                    item.argon = false;
                }
            }

            // NEW FUNCTION: Update leaves dropdown based on system type
            function updateLeavesDropdown(itemId, systemType) {
                const leavesSelect = document.querySelector(
                    `#leaves-${itemId}`
                );
                if (!leavesSelect) return;

                // Save current selection
                const currentValue = leavesSelect.value;

                // Clear existing options
                leavesSelect.innerHTML = "";

                // Add options based on system type
                if (systemType === "hinged" || systemType === "fixed") {
                    leavesSelect.innerHTML = `
                    <option value="1">1 Leaf</option>
                    <option value="2">2 Leaves</option>
                `;
                } else {
                    leavesSelect.innerHTML = `
                    <option value="2">2 Leaves</option>
                    <option value="3">3 Leaves</option>
                    <option value="4">4 Leaves</option>
                `;
                }

                // Restore previous selection if still valid
                if (
                    leavesSelect.querySelector(
                        `option[value="${currentValue}"]`
                    )
                ) {
                    leavesSelect.value = currentValue;
                } else {
                    // Default to 2 leaves if previous selection is invalid
                    leavesSelect.value = "2";
                }

                // Add event listener to ensure SVG regeneration when leaves change
                leavesSelect.addEventListener("change", function () {
                    const item = items.find((item) => item.id === itemId);
                    if (item) {
                        item.leaves = parseInt(this.value);
                        item.visualSvg = generateNormalItemSvg(item);
                        updateNormalItemSummary(item.id);
                    }
                    // Toggle upper panel type field visibility
                    toggleUpperPanelTypeField(itemId);
                });

                // Update item data
                const item = items.find((item) => item.id === itemId);
                if (item) {
                    item.leaves = parseInt(leavesSelect.value);

                    // Always regenerate SVG when leaves change (regardless of dimensions)
                    item.visualSvg = generateNormalItemSvg(item);

                    // Update the summary display
                    updateNormalItemSummary(item.id);
                }

                // Also update net type visibility
                toggleNetTypeField(itemId);
            }

            // Show/hide net type field based on conditions
            function toggleNetTypeField(itemId) {
                const item = items.find((item) => item.id === itemId);
                if (!item) return;
                const itemElement = document.getElementById(itemId);
                if (!itemElement) return;

                const system = itemElement.querySelector(".item-system").value;
                const mosquitoChecked =
                    itemElement.querySelector(".item-mosquito").checked;
                const netTypeContainer = document.getElementById(
                    `net-type-container-${itemId}`
                );

                // Show only for hinged systems with mosquito net enabled
                if (system === "hinged" && mosquitoChecked) {
                    netTypeContainer.style.display = "block";
                } else {
                    netTypeContainer.style.display = "none";
                }
            }

            // Show/hide upper panel type field based on conditions
            function toggleUpperPanelTypeField(itemId) {
                const item = items.find((item) => item.id === itemId);
                if (!item) return;
                const itemElement = document.getElementById(itemId);
                if (!itemElement) return;

                const system = itemElement.querySelector(".item-system").value;
                const leaves =
                    parseInt(itemElement.querySelector(".item-leaves").value) ||
                    0;
                const upperPanelContainer = document.getElementById(
                    `upper-panel-type-${itemId}`
                );

                // Show only for hinged systems with 2 leaves
                if (system === "hinged" && leaves === 2) {
                    upperPanelContainer.style.display = "block";
                } else {
                    upperPanelContainer.style.display = "none";
                }
            }

            function updateProfileOptions(itemId) {
                const item = items.find((item) => item.id === itemId);
                if (!item || item.type === "curtain_wall") return;

                const itemElement = document.getElementById(itemId);
                if (!itemElement) return;

                // Update item data
                item.type = itemElement.querySelector(".item-type").value;
                item.width =
                    parseFloat(
                        itemElement.querySelector(".item-width").value
                    ) || 0;
                item.height =
                    parseFloat(
                        itemElement.querySelector(".item-height").value
                    ) || 0;
                item.quantity =
                    parseInt(
                        itemElement.querySelector(".item-quantity").value
                    ) || 1;
                item.system = itemElement.querySelector(".item-system").value;

                // Generate SVG for normal items when dimensions change
                if (item.width && item.height) {
                    console.log(
                        "Generating SVG for normal item:",
                        item.id,
                        "with dimensions:",
                        item.width,
                        "x",
                        item.height
                    );
                    item.visualSvg = generateNormalItemSvg(item);
                    console.log(
                        "Generated SVG for normal item:",
                        item.id,
                        "SVG length:",
                        item.visualSvg?.length
                    );

                    // Update the summary display
                    updateNormalItemSummary(item.id);
                } else {
                    console.log(
                        "No dimensions for normal item:",
                        item.id,
                        "setting visualSvg to null"
                    );
                    item.visualSvg = null;

                    // Hide the summary if no dimensions
                    const summaryEl = document.querySelector(
                        `#normalItemSummary-${item.id}`
                    );
                    if (summaryEl) {
                        summaryEl.style.display = "none";
                    }
                }

                // Show profile selection section
                const profileSection = document.getElementById(
                    `profile-selection-${itemId}`
                );
                const profileGrid = document.getElementById(
                    `profile-grid-${itemId}`
                );
                const noProfiles = document.getElementById(
                    `no-profiles-${itemId}`
                );
                const loading = document.getElementById(
                    `profile-loading-${itemId}`
                );

                // Hide everything initially
                profileSection.style.display = "none";
                profileGrid.innerHTML = "";
                noProfiles.style.display = "none";
                loading.style.display = "block";

                // Only show if we have all required data
                if (!item.type || !item.system || !item.width || !item.height) {
                    return;
                }

                // Show the profile section
                profileSection.style.display = "block";

                // Filter profiles based on system and dimensions
                const filteredProfiles = profiles.filter((profile) => {
                    // Convert max_h and max_w to numbers
                    const maxH = parseFloat(profile.max_h) || 0;
                    const maxW = parseFloat(profile.max_w) || 0;

                    return (
                        profile.system === item.system &&
                        maxH >= item.height &&
                        maxW >= item.width
                    );
                });

                // Hide loading after delay to show we've processed
                setTimeout(() => {
                    loading.style.display = "none";

                    if (filteredProfiles.length === 0) {
                        noProfiles.style.display = "block";
                        return;
                    }

                    // Display available profiles
                    filteredProfiles.forEach((profile) => {
                        const profileCard = document.createElement("div");
                        profileCard.className = "profile-card";
                        profileCard.onclick = () =>
                            selectProfile(itemId, profile);

                        profileCard.innerHTML = `
                        <div class="profile-header">
                            <div class="profile-brand">${profile.Brand}</div>
                            <div class="profile-code">${profile.profile_code}</div>
                        </div>
                        <div class="profile-name">${profile.profile_name}</div>
                        <div class="profile-specs">
                            <div class="spec-item">
                                <span class="spec-label">Max Height</span>
                                <span class="spec-value">${profile.max_h} m</span>
                            </div>
                            <div class="spec-item">
                                <span class="spec-label">Max Width</span>
                                <span class="spec-value">${profile.max_w} m</span>
                            </div>
                            <div class="spec-item">
                                <span class="spec-label">System</span>
                                <span class="spec-value">${profile.system}</span>
                            </div>
                            <div class="spec-item">
                                <span class="spec-label">Frame Price</span>
                                <span class="spec-value">${profile.frame_price} EGP</span>
                            </div>
                        </div>
                        <div class="profile-notice">
                            <i class="fas fa-info-circle"></i>
                            <span>This profile can accommodate your dimensions of ${item.width}m x ${item.height}m</span>
                        </div>
                    `;

                        profileGrid.appendChild(profileCard);
                    });
                }, 500);
            }

            function selectProfile(itemId, profile) {
                const item = items.find((item) => item.id === itemId);
                if (!item) return;

                // Update item with selected profile
                item.profile = profile;

                // Generate SVG for normal items when profile is selected
                if (item.width && item.height) {
                    item.visualSvg = generateNormalItemSvg(item);

                    // Update the summary display
                    updateNormalItemSummary(item.id);
                }

                // Update UI - mark selected card
                const profileGrid = document.getElementById(
                    `profile-grid-${itemId}`
                );
                if (!profileGrid) return;

                const profileCards =
                    profileGrid.querySelectorAll(".profile-card");

                profileCards.forEach((card) => {
                    card.classList.remove("selected");
                    const profileCodeEl = card.querySelector(".profile-code");
                    if (
                        profileCodeEl &&
                        profileCodeEl.textContent === profile.profile_code
                    ) {
                        card.classList.add("selected");

                        // Add selected badge if not already present
                        const existingBadge = card.querySelector(
                            ".profile-selected-badge"
                        );
                        if (!existingBadge) {
                            const badge = document.createElement("div");
                            badge.className = "profile-selected-badge";
                            badge.innerHTML =
                                '<i class="fas fa-check"></i> Selected';
                            card.appendChild(badge);
                        }
                    }
                });
            }

            function generateUniqueId() {
                const timestamp = Date.now().toString(36);
                const random = Math.random().toString(36).substr(2, 5);
                return `ITEM-${timestamp}-${random}`;
            }

            function generateQuoteId() {
                const timestamp = Date.now().toString(36).toUpperCase();
                const random = Math.floor(Math.random() * 10000)
                    .toString()
                    .padStart(4, "0");
                return `QU-${timestamp}-${random}`;
            }

            function removeItem(itemId) {
                const itemElement = document.getElementById(itemId);
                if (itemElement) {
                    itemElement.remove();
                    items = items.filter((item) => item.id !== itemId);
                    itemCount--;

                    // Update item numbers
                    const itemCards = document.querySelectorAll(".item-card");
                    itemCards.forEach((card, index) => {
                        const title = card.querySelector(".item-title");
                        if (title) {
                            title.textContent = `Item #${index + 1}`;
                        }
                    });
                }
            }

            function nextStep(step) {
                // Before moving to next step, update all form data
                updateItemsData();

                // Only validate items when LEAVING step 2 (going to step 3 or 4)
                if (currentStep === 2 && step > 2 && !validateItems()) {
                    return false;
                }

                // Update summary if going to step 4
                if (step === 4) {
                    updateSummary();
                }

                document
                    .getElementById(`step${currentStep}`)
                    .classList.remove("active");
                currentStep = step;
                document
                    .getElementById(`step${currentStep}`)
                    .classList.add("active");

                // Update progress bar
                document
                    .querySelectorAll(".progress-step")
                    .forEach((el, index) => {
                        if (index < step) {
                            el.classList.add("active");
                        } else {
                            el.classList.remove("active");
                        }
                    });
            }

            // Validate items (simplified version)
            function validateItems() {
                if (items.length === 0) {
                    alert("Please add at least one item to continue.");
                    return false;
                }

                for (const item of items) {
                    if (!item.type) {
                        alert(
                            `Please select a type for Item #${
                                item.id.split("-")[1]
                            }`
                        );
                        return false;
                    }

                    if (item.type === "curtain_wall") {
                        // For curtain walls, we need at least a profile selection
                        if (!item.curtain.profile) {
                            alert(
                                `Please select a profile for your Curtain Wall (Item #${
                                    item.id.split("-")[1]
                                })`
                            );
                            return false;
                        }
                    } else {
                        if (!item.width || !item.height || !item.system) {
                            alert(
                                `Please complete all required fields for Item #${
                                    item.id.split("-")[1]
                                }`
                            );
                            return false;
                        }
                    }
                }

                return true;
            }

            function prevStep(step) {
                document
                    .getElementById(`step${currentStep}`)
                    .classList.remove("active");
                currentStep = step;
                document
                    .getElementById(`step${currentStep}`)
                    .classList.add("active");

                // Update progress bar
                document
                    .querySelectorAll(".progress-step")
                    .forEach((el, index) => {
                        if (index < step) {
                            el.classList.add("active");
                        } else {
                            el.classList.remove("active");
                        }
                    });
            }

            function updateItemsData() {
                // Update all items data
                items.forEach((item) => {
                    const itemElement = document.getElementById(item.id);
                    if (!itemElement) return;

                    item.type = itemElement.querySelector(".item-type").value;

                    if (item.type === "curtain_wall") {
                        // For curtain wall items, update from curtain-specific fields
                        const quantityInput =
                            itemElement.querySelector(".curtain-quantity");
                        item.curtain.quantity = quantityInput
                            ? parseInt(quantityInput.value) || 1
                            : 1;

                        // Get curtain wall glass type selection
                        const glassTypeRadio = itemElement.querySelector(
                            `input[name="curtainGlassType-${item.id}"]:checked`
                        );
                        if (glassTypeRadio) {
                            item.curtain.glassType = glassTypeRadio.value;
                        }

                        // Get curtain wall design data if available
                        const curtainDesignDataInput =
                            itemElement.querySelector(
                                'input[name="curtainWallData"]'
                            );
                        if (
                            curtainDesignDataInput &&
                            curtainDesignDataInput.value
                        ) {
                            try {
                                item.curtain.designData = JSON.parse(
                                    curtainDesignDataInput.value
                                );
                                // Also update the item's direct properties from designData for easier access
                                item.curtain.wallWidth =
                                    item.curtain.designData.wallWidth || 0;
                                item.curtain.wallHeight =
                                    item.curtain.designData.wallHeight || 0;
                                item.curtain.cols =
                                    item.curtain.designData.cols || 0;
                                item.curtain.rows =
                                    item.curtain.designData.rows || 0;
                                item.curtain.frameMeters =
                                    item.curtain.designData.frameMeters || 0;
                                item.curtain.windowMeters =
                                    item.curtain.designData.windowMeters || 0;
                                item.curtain.glassArea =
                                    item.curtain.designData.glassArea || 0;
                                item.curtain.cornerCount =
                                    item.curtain.designData.cornerCount || 0;
                                item.curtain.panels =
                                    item.curtain.designData.panels || [];

                                // Generate SVG here for submission
                                console.log(
                                    "Generating SVG for curtain wall item:",
                                    item.id
                                );
                                item.curtain.visualSvg = generateCurtainWallSvg(
                                    item.curtain.designData
                                );
                                console.log(
                                    "Generated SVG for curtain wall item:",
                                    item.id,
                                    "SVG length:",
                                    item.curtain.visualSvg?.length
                                );
                            } catch (e) {
                                console.error(
                                    "Error parsing curtain wall design data:",
                                    e
                                );
                                item.curtain.designData = null;
                                item.curtain.visualSvg = null;
                            }
                        }
                    } else {
                        // For normal items
                        item.width =
                            parseFloat(
                                itemElement.querySelector(".item-width").value
                            ) || 0;
                        item.height =
                            parseFloat(
                                itemElement.querySelector(".item-height").value
                            ) || 0;
                        item.quantity =
                            parseInt(
                                itemElement.querySelector(".item-quantity")
                                    .value
                            ) || 1;
                        item.system =
                            itemElement.querySelector(".item-system").value;
                        item.leaves =
                            parseInt(
                                itemElement.querySelector(".item-leaves").value
                            ) || 2;
                        item.color =
                            itemElement.querySelector(".item-color").value;

                        // Glass type
                        const glassTypeRadio = itemElement.querySelector(
                            ".item-glass-type input:checked"
                        );
                        item.glassType = glassTypeRadio
                            ? glassTypeRadio.value
                            : "double";

                        // Glass appearance
                        item.glassAppearance = itemElement.querySelector(
                            ".item-glass-appearance"
                        ).value;

                        // Checkbox options
                        item.argon =
                            itemElement.querySelector(".item-argon").checked;
                        item.mosquito =
                            itemElement.querySelector(".item-mosquito").checked;
                        item.arch =
                            itemElement.querySelector(".item-arch").checked;

                        // Net type (only if mosquito net is checked)
                        item.netType = null;
                        if (item.mosquito) {
                            item.netType =
                                itemElement.querySelector(
                                    ".item-net-type"
                                ).value;
                        }

                        // Upper panel type (for hinged items with 2 leaves)
                        const upperPanelSelect = itemElement.querySelector(
                            ".item-upper-panel-type"
                        );
                        if (
                            upperPanelSelect &&
                            item.system === "hinged" &&
                            item.leaves === 2
                        ) {
                            item.upperPanelType = upperPanelSelect.value;
                            console.log(
                                "updateItemsData - Updated item.upperPanelType to:",
                                item.upperPanelType
                            );
                        } else {
                            item.upperPanelType = "hinged"; // default
                        }

                        // Generate SVG for normal items
                        if (item.width && item.height) {
                            item.visualSvg = generateNormalItemSvg(item);
                        } else {
                            item.visualSvg = null;
                        }
                    }
                });
            }

            function updateSummary() {
                const summaryContainer =
                    document.getElementById("summary-items");
                if (!summaryContainer) return;

                // Clear existing content but keep the heading
                const heading = summaryContainer.querySelector("h3");
                summaryContainer.innerHTML = "";
                if (heading) summaryContainer.appendChild(heading);

                // Update project details
                const projectType =
                    document.querySelector('input[name="projectType"]:checked')
                        ?.value || "Not selected";
                const contactMethod =
                    document.querySelector(
                        'input[name="contactMethod"]:checked'
                    )?.value || "Not selected";

                document.getElementById("summary-project-type").textContent =
                    projectType.charAt(0).toUpperCase() + projectType.slice(1);
                document.getElementById("summary-total-items").textContent =
                    items.length;
                document.getElementById("summary-contact-method").textContent =
                    contactMethod.charAt(0).toUpperCase() +
                    contactMethod.slice(1);

                // Process each item for summary display
                items.forEach((item) => {
                    const summaryItem = document.createElement("div");
                    summaryItem.className = "summary-item";

                    if (item.type === "curtain_wall") {
                        console.log(
                            "Displaying curtain wall item in summary:",
                            item.id,
                            "visualSvg length:",
                            item.curtain.visualSvg?.length
                        );
                        summaryItem.innerHTML = `
                        <div>
                            <div class="summary-label">Item ID: ${
                                item.uniqueId
                            }</div>
                            <div>Curtain Wall</div>
                            <div>Profile: ${
                                item.curtain.profile
                                    ? item.curtain.profile.profile_name
                                    : "Not selected"
                            }</div>
                            <div>Glass Type: ${
                                item.curtain.glassType || "double"
                            }</div>
                            <div>Quantity: ${item.curtain.quantity || 1}</div>
                            ${
                                item.curtain.visualSvg
                                    ? `<div style="margin-top: 10px; border: 1px solid #eee; padding: 5px; border-radius: 4px;">${item.curtain.visualSvg}</div>`
                                    : ""
                            }
                        </div>
                        <div class="summary-value">${
                            item.curtain.profile
                                ? item.curtain.profile.system
                                : "Curtain Wall System"
                        }</div>
                    `;
                    } else {
                        console.log(
                            "Displaying normal item in summary:",
                            item.id,
                            "visualSvg length:",
                            item.visualSvg?.length
                        );
                        summaryItem.innerHTML = `
                        <div>
                            <div class="summary-label">Item ID: ${
                                item.uniqueId
                            }</div>
                            <div>${
                                item.type
                                    ? item.type.charAt(0).toUpperCase() +
                                      item.type.slice(1)
                                    : "Item"
                            }</div>
                            <div>${item.width || 0}m  ${
                            item.height || 0
                        }m</div>
                            <div>Leaves: ${item.leaves || 0}</div>
                            <div>Glass Type: ${item.glassType || "double"}</div>
                            <div>Quantity: ${item.quantity || 1}</div>
                            <div>Profile: ${
                                item.profile
                                    ? item.profile.profile_name
                                    : "Not selected"
                            }</div>
                            ${
                                item.visualSvg
                                    ? `<div style="margin-top: 10px; border: 1px solid #eee; padding: 5px; border-radius: 4px;">${item.visualSvg}</div>`
                                    : ""
                            }
                        </div>
                        <div class="summary-value">${
                            item.system || "System not selected"
                        }</div>
                    `;
                    }

                    summaryContainer.appendChild(summaryItem);
                });

                // Add note about pricing calculation
                const pricingNote = document.createElement("div");
                pricingNote.className = "recommendation";
                pricingNote.innerHTML = `
                <h4><i class="fas fa-calculator"></i> Pricing Information</h4>
                <p>Click the "Calculate Pricing" button above to get detailed pricing breakdown with profit margins, payment schedule, and total project cost.</p>
                <p>The calculation uses the exact same formula as your n8n workflow and includes all cost components.</p>
            `;
                summaryContainer.appendChild(pricingNote);
            }
            window.addEventListener("message", function (event) {
                // only care about our messages
                if (!event.data || event.data.type !== "curtainWallData")
                    return;

                // find the iframe that actually sent the message (works for local/null origin too)
                const iframes = Array.from(document.querySelectorAll("iframe"));
                const iframe = iframes.find((f) => {
                    try {
                        return f.contentWindow === event.source;
                    } catch (e) {
                        return false;
                    }
                });
                if (!iframe) {
                    console.warn("Curtain message: no matching iframe found.");
                    return;
                }

                // find the item container for that iframe
                const itemId = iframe.dataset.itemId; // Use data-item-id attribute
                const itemContainer = document.getElementById(itemId);

                if (!itemContainer) {
                    console.warn(
                        "Curtain message: iframe found but no .item-card parent with matching ID."
                    );
                    return;
                }

                const item =
                    window.items && itemId
                        ? window.items.find((it) => it.id === itemId)
                        : null;

                // payload from designer
                const payload = event.data.payload || {};

                // store payload to the item object if available (keeps rest of app consistent)
                // store under .designData so other code (updateItemsData / submit) can reliably find it
                if (item) {
                    item.curtain = Object.assign(
                        {},
                        item.curtain || {},
                        { designData: payload },
                        { lastUpdated: new Date().toISOString() }
                    );
                    // Update item's direct properties from designData for easier access
                    item.curtain.wallWidth = payload.wallWidth || 0;
                    item.curtain.wallHeight = payload.wallHeight || 0;
                    item.curtain.cols = payload.cols || 0;
                    item.curtain.rows = payload.rows || 0;
                    item.curtain.frameMeters = payload.frameMeters || 0;
                    item.curtain.windowMeters = payload.windowMeters || 0;
                    item.curtain.glassArea = payload.glassArea || 0;
                    item.curtain.cornerCount = payload.cornerCount || 0;
                    item.curtain.panels = payload.panels || [];

                    // Generate SVG here for display and submission
                    item.curtain.visualSvg = generateCurtainWallSvg(payload);
                } else {
                    // fallback: attach to DOM element so other code can find it
                    itemContainer.__curtainPayload = payload;
                }

                // hide designer, show summary
                // IMPORTANT: designer/summary elements use IDs with the itemId suffix (e.g curtainWallDesigner-item-1)
                const designerEl = itemContainer.querySelector(
                    `#curtainWallDesigner-${itemId}`
                );
                const summaryEl = itemContainer.querySelector(
                    `#curtainWallSummary-${itemId}`
                );
                if (designerEl) designerEl.style.display = "none";
                if (summaryEl) summaryEl.style.display = "block";

                // persist JSON into hidden input for exports
                if (summaryEl) {
                    let hiddenInput = summaryEl.querySelector(
                        "input[name='curtainWallData']"
                    );
                    if (!hiddenInput) {
                        hiddenInput = document.createElement("input");
                        hiddenInput.type = "hidden";
                        hiddenInput.name = "curtainWallData";
                        summaryEl.appendChild(hiddenInput);
                    }
                    hiddenInput.value = JSON.stringify(payload);
                }

                // Render the visual INTO the summary area:
                if (summaryEl) {
                    let shapeEl = summaryEl.querySelector(
                        `#curtainWallShape-${itemId}`
                    );
                    if (!shapeEl) {
                        shapeEl = document.createElement("div");
                        shapeEl.id = `curtainWallShape-${itemId}`;
                        summaryEl.appendChild(shapeEl);
                    }

                    // Use the generated SVG
                    if (item && item.curtain.visualSvg) {
                        shapeEl.innerHTML = item.curtain.visualSvg;
                    } else {
                        shapeEl.innerHTML =
                            "<em>Design saved  visual generator missing.</em>";
                    }
                }

                // call existing hooks if present
                if (typeof window.updateCurtainWallSummary === "function") {
                    try {
                        window.updateCurtainWallSummary(
                            itemId,
                            item ? item.curtain.designData : payload
                        );
                    } catch (e) {
                        /* ignore */
                    }
                }
                if (typeof window.calculateProjectTotals === "function") {
                    try {
                        window.calculateProjectTotals();
                    } catch (e) {
                        /* ignore */
                    }
                }

                console.info(
                    "Curtain data processed for",
                    itemId || itemContainer
                );
            });

            function editCurtainWall(triggeringElementOrItemId) {
                // allow calling by (a) itemId string, (b) a DOM element inside the card (like a button),
                // or (c) default to first .item-card
                let itemContainer = null;
                if (typeof triggeringElementOrItemId === "string") {
                    itemContainer = document.getElementById(
                        triggeringElementOrItemId
                    );
                } else if (triggeringElementOrItemId instanceof Element) {
                    itemContainer =
                        triggeringElementOrItemId.closest(".item-card") ||
                        triggeringElementOrItemId.closest(".item");
                } else {
                    itemContainer = document.querySelector(".item-card, .item");
                }
                if (!itemContainer) return;

                const itemId = itemContainer.id; // Get the item ID
                const designerEl = itemContainer.querySelector(
                    `#curtainWallDesigner-${itemId}`
                );
                const summaryEl = itemContainer.querySelector(
                    `#curtainWallSummary-${itemId}`
                );
                if (designerEl) designerEl.style.display = "block";
                if (summaryEl) summaryEl.style.display = "none";

                // Get design data from hidden input or item object
                const hidden =
                    summaryEl &&
                    summaryEl.querySelector("input[name='curtainWallData']");
                const item = items.find((it) => it.id === itemId);
                const designData = item?.curtain?.designData;

                let dataToLoad = null;

                if (hidden && hidden.value) {
                    try {
                        dataToLoad = JSON.parse(hidden.value);
                    } catch (e) {
                        console.warn("Failed to parse hidden curtain data:", e);
                    }
                }

                // Fallback to item's design data if hidden input is empty
                if (!dataToLoad && designData) {
                    dataToLoad = designData;
                }

                // Load the design data into the embedded designer
                if (dataToLoad) {
                    console.log(
                        "Loading curtain wall design data into embedded designer:",
                        dataToLoad
                    );
                    setTimeout(() => {
                        loadCurtainDesignData(itemId, dataToLoad);
                    }, 100);
                } else {
                    console.log("No curtain wall design data found to load");
                }
            }

            function exportDesign() {
                // Build full design object
                const design = {
                    wallWidth: state.wallWidth,
                    wallHeight: state.wallHeight,
                    cols: state.cols,
                    rows: state.rows,
                    panels: state.panels || [],
                    mergedPanels: state.mergedPanels
                        ? Array.from(state.mergedPanels.values())
                        : [],
                    selectedProfiles: state.selectedProfiles || [],
                    notes: state.notes || "",
                    timestamp: new Date().toISOString(),
                };

                // Write to hidden input
                const hidden = document.getElementById("designData");
                if (hidden) {
                    hidden.value = JSON.stringify(design, null, 2);
                } else {
                    console.error(
                        "Hidden input #designData not found in form."
                    );
                }

                // Submit form
                const form = document.getElementById("designForm");
                if (form) {
                    form.submit();
                } else {
                    console.error("Form #designForm not found.");
                }
            }

            // Export project data as JSON - FIXED FOR CURTAIN WALL
            function exportProjectData() {
                updateItemsData(); // Ensure all data is up to date

                const projectType = document.querySelector(
                    'input[name="projectType"]:checked'
                ).value;
                const contactMethod = document.querySelector(
                    'input[name="contactMethod"]:checked'
                ).value;

                // Contact info
                const contactInfo = {
                    name: document.getElementById("contact-name").value,
                    phone: document.getElementById("contact-phone").value,
                    email: document.getElementById("contact-email").value,
                    method: contactMethod,
                    location: document.getElementById("contact-location").value,
                    notes: document.getElementById("contact-notes").value,
                };

                // Calculate totals
                let totalFrameMeters = 0;
                let totalWindowMeters = 0;
                let totalGlassArea = 0;
                let totalEstimatedValue = 0;

                // Prepare the export data
                const exportData = {
                    projectType: projectType,
                    contactInfo: contactInfo,
                    items: items.map((item) => {
                        if (item.type === "curtain_wall") {
                            // For curtain wall items
                            const curtainData = {
                                id: item.uniqueId,
                                type: item.type,
                                quantity: item.curtain.quantity,
                                glassType: item.curtain.glassType || "double",
                                profile: item.curtain.profile
                                    ? {
                                          code: item.curtain.profile
                                              .profile_code,
                                          name: item.curtain.profile
                                              .profile_name,
                                          brand: item.curtain.profile.Brand,
                                          price: item.curtain.profile
                                              .frame_price,
                                      }
                                    : null,
                                designData: item.curtain.designData,
                                visualSvg: item.curtain.visualSvg, // Include the generated SVG
                            };

                            // Add to totals
                            if (item.curtain.designData) {
                                totalFrameMeters +=
                                    (item.curtain.designData.frameMeters || 0) *
                                    (item.curtain.quantity || 1);
                                totalWindowMeters +=
                                    (item.curtain.designData.windowMeters ||
                                        0) * (item.curtain.quantity || 1);
                                totalGlassArea +=
                                    (item.curtain.designData.glassArea || 0) *
                                    (item.curtain.quantity || 1);

                                if (item.curtain.profile) {
                                    totalEstimatedValue +=
                                        parseFloat(
                                            item.curtain.profile.frame_price
                                        ) *
                                        (item.curtain.designData.frameMeters ||
                                            0) *
                                        (item.curtain.quantity || 1);
                                }
                            }

                            return curtainData;
                        } else {
                            // For normal items
                            const normalData = {
                                id: item.uniqueId,
                                type: item.type,
                                width: item.width,
                                height: item.height,
                                quantity: item.quantity,
                                leaves: item.leaves,
                                system: item.system,
                                glassType: item.glassType,
                                profile: item.profile
                                    ? {
                                          code: item.profile.profile_code,
                                          name: item.profile.profile_name,
                                          brand: item.profile.Brand,
                                          price: item.profile.frame_price,
                                      }
                                    : null,
                                color: item.color,
                                glassAppearance: item.glassAppearance,
                                argon: item.argon,
                                mosquito: item.mosquito,
                                netType: item.netType,
                                arch: item.arch,
                            };

                            // Add to totals
                            const perimeter =
                                ((item.width || 0) + (item.height || 0)) * 2;
                            totalFrameMeters +=
                                perimeter *
                                (item.leaves || 1) *
                                (item.quantity || 1);
                            totalWindowMeters +=
                                perimeter *
                                (item.leaves || 1) *
                                (item.quantity || 1);
                            totalGlassArea +=
                                item.width * item.height * item.quantity;

                            if (item.profile) {
                                totalEstimatedValue +=
                                    parseFloat(item.profile.frame_price) *
                                    (item.width * item.height) *
                                    item.quantity;
                            }

                            return normalData;
                        }
                    }),
                    totals: {
                        frameMeters: totalFrameMeters,
                        windowMeters: totalWindowMeters,
                        glassArea: totalGlassArea,
                        estimatedValue: totalEstimatedValue,
                    },
                    timestamp: new Date().toISOString(),
                };

                // Create a blob and download it
                const blob = new Blob([JSON.stringify(exportData, null, 2)], {
                    type: "application/json",
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = `cocoon-quote-${new Date()
                    .toISOString()
                    .slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            async function submitForm() {
                // Show loading
                const submitBtn = document.getElementById("submit-btn");
                const originalText = submitBtn.innerHTML;
                submitBtn.innerHTML =
                    '<span class="loading"></span> Sending...';
                submitBtn.disabled = true;

                try {
                    // Generate quote ID
                    quoteId = generateQuoteId();

                    // Update items data one last time
                    updateItemsData(); // This will now also generate visualSvg for curtain walls

                    // Contact info
                    const contactInfo = {
                        name: document.getElementById("contact-name").value,
                        phone: document.getElementById("contact-phone").value,
                        email: document.getElementById("contact-email").value,
                        method: document.querySelector(
                            'input[name="contactMethod"]:checked'
                        ).value,
                        location:
                            document.getElementById("contact-location").value,
                        notes: document.getElementById("contact-notes").value,
                    };

                    const bodyTimestamp = new Date().toISOString();

                    const mappedItems = items.map((it) => {
                        // base fields
                        const base = {
                            id: it.uniqueId,
                            type: it.type,
                            width:
                                it.width ||
                                (it.curtain && it.curtain.wallWidth) ||
                                0, // Use curtain.wallWidth for curtain walls
                            height:
                                it.height ||
                                (it.curtain && it.curtain.wallHeight) ||
                                0, // Use curtain.wallHeight for curtain walls
                            quantity:
                                it.type === "curtain_wall"
                                    ? (it.curtain && it.curtain.quantity) || 1
                                    : it.quantity || 1,
                            system: it.system || null,
                            glassType:
                                it.type === "curtain_wall"
                                    ? it.curtain.glassType || "double"
                                    : it.glassType || "double",
                            profile:
                                (it.profile && it.profile.profile_code) ||
                                (it.curtain &&
                                    it.curtain.profile &&
                                    it.curtain.profile.profile_code) ||
                                null,
                            color: it.color || null,
                            glassAppearance: it.glassAppearance || "clear",
                            argon: !!it.argon,
                            mosquito: !!it.mosquito,
                            netType: it.netType || null,
                            arch: !!it.arch,
                            leaves: it.leaves || 2,
                            upperPanelType: it.upperPanelType || "hinged",
                            frameMeters: 0,
                            windowMeters: 0,
                            glassArea: 0,
                            cornerCount: 0,
                            cols: 0,
                            rows: 0,
                            panels: [],
                            visualSvg: null, // Changed from visualHtml to visualSvg
                        };

                        if (it.type === "curtain_wall") {
                            const d = it.curtain; // d is now the item.curtain object directly
                            base.frameMeters = d.frameMeters || 0;
                            base.windowMeters = d.windowMeters || 0;
                            base.glassArea = d.glassArea || 0;
                            base.cornerCount = d.cornerCount || 0;
                            base.cols = d.cols || 0;
                            base.rows = d.rows || 0;
                            base.panels = Array.isArray(d.panels)
                                ? d.panels
                                : [];

                            // Use the generated SVG
                            base.visualSvg =
                                d.visualSvg ||
                                "<em>No visual representation available</em>";

                            // include profile details if present
                            if (d.profile) {
                                base.profileDetails = Object.assign(
                                    {},
                                    d.profile
                                );
                            }
                        } else {
                            // approximate for normal items
                            const perimeter =
                                ((base.width || 0) + (base.height || 0)) * 2;
                            base.frameMeters =
                                perimeter *
                                (base.leaves || 1) *
                                (base.quantity || 1);
                            base.windowMeters = base.frameMeters;
                            base.glassArea =
                                (base.width || 0) *
                                (base.height || 0) *
                                (base.quantity || 1);
                            base.panels = [];
                            // Use the generated SVG for normal items
                            base.visualSvg =
                                item.visualSvg ||
                                "<em>No visual representation available</em>";
                        }

                        return base;
                    });

                    const messageBody = {
                        quoteId: quoteId,
                        projectType: document.querySelector(
                            'input[name="projectType"]:checked'
                        ).value,
                        items: mappedItems,
                        contactInfo: contactInfo,
                        timestamp: bodyTimestamp,
                    };

                    // Log the complete payload for debugging
                    console.log("Form submission payload:", messageBody);

                    // Build headers object
                    const urlObj = new URL(WEBHOOK_URL);
                    const bodyString = JSON.stringify(messageBody);
                    const headersObj = {
                        host: urlObj.host,
                        "user-agent": navigator.userAgent || "",
                        "content-length": String(bodyString.length),
                        accept: "*/*",
                        "accept-encoding": "gzip, br",
                        "accept-language": navigator.language || "",
                        origin: location.origin || "",
                        referer: document.referrer || location.href,
                        "content-type": "application/json",
                        "x-forwarded-for": "",
                        "x-forwarded-host": urlObj.host,
                        "x-forwarded-proto": urlObj.protocol.replace(":", ""),
                    };

                    const webhookMessage = [
                        {
                            headers: headersObj,
                            params: {},
                            query: {},
                            body: messageBody,
                            webhookUrl: WEBHOOK_URL,
                            executionMode: "production",
                        },
                    ];

                    // Send data to webhook
                    const response = await fetch(WEBHOOK_URL, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify(webhookMessage),
                    });

                    if (response.ok) {
                        // Show success message with quote ID
                        document.getElementById(
                            "quote-id-display"
                        ).textContent = quoteId;
                        document
                            .getElementById(`step${currentStep}`)
                            .classList.remove("active");
                        document
                            .getElementById("success")
                            .classList.add("active");
                    } else {
                        throw new Error("Failed to submit form");
                    }
                } catch (error) {
                    // Show error notification
                    alert(
                        "There was an error submitting your form. Please try again."
                    );
                    console.error(error);
                    submitBtn.innerHTML = originalText;
                    submitBtn.disabled = false;
                }
            }

            function resetForm() {
                // Reset to first step
                document.getElementById("success").classList.remove("active");
                currentStep = 1;
                document
                    .getElementById(`step${currentStep}`)
                    .classList.add("active");

                // Reset progress bar
                document
                    .querySelectorAll(".progress-step")
                    .forEach((el, index) => {
                        if (index === 0) {
                            el.classList.add("active");
                        } else {
                            el.classList.remove("active");
                        }
                    });

                // Reset form fields
                document.getElementById("items-container").innerHTML = "";
                document.getElementById("contact-name").value = "";
                document.getElementById("contact-phone").value = "";
                document.getElementById("contact-email").value = "";
                document.getElementById("contact-location").value = "";
                document.getElementById("contact-notes").value = "";

                // Reset items array
                itemCount = 0;
                items = [];

                // Add first item again
                addNewItem();

                // Reset quote ID
                quoteId = null;

                // Reset submit button state
                const submitBtn = document.getElementById("submit-btn");
                submitBtn.innerHTML =
                    '<i class="fas fa-paper-plane"></i> Request Quote';
                submitBtn.disabled = false;
            }

            function editCurtainWall(itemId) {
                const itemElement = document.getElementById(itemId);
                if (!itemElement) return;

                const curtainDesigner = itemElement.querySelector(
                    `#curtainWallDesigner-${itemId}`
                );
                const curtainSummary = itemElement.querySelector(
                    `#curtainWallSummary-${itemId}`
                );

                if (curtainDesigner && curtainSummary) {
                    curtainDesigner.style.display = "block";
                    curtainSummary.style.display = "none";
                }
            }

            window.addEventListener("message", function (event) {
                if (event.data && event.data.type === "curtainWallData") {
                    // Extract item ID from the iframe
                    // Find the iframe that sent the message using its data-item-id attribute
                    const iframes = document.querySelectorAll(
                        'iframe[src="curtain-wall-designer.html"]'
                    );
                    let itemId = null;
                    for (let i = 0; i < iframes.length; i++) {
                        if (iframes[i].contentWindow === event.source) {
                            itemId = iframes[i].dataset.itemId;
                            break;
                        }
                    }

                    if (!itemId) return; // If no matching iframe found, exit

                    const data = event.data.payload;

                    const itemElement = document.getElementById(itemId);
                    if (!itemElement) return;

                    const curtainDesigner = itemElement.querySelector(
                        `#curtainWallDesigner-${itemId}`
                    );
                    const curtainSummary = itemElement.querySelector(
                        `#curtainWallSummary-${itemId}`
                    );

                    if (curtainDesigner && curtainSummary) {
                        curtainDesigner.style.display = "none";
                        curtainSummary.style.display = "block";

                        // Update the item data
                        const item = items.find((item) => item.id === itemId);
                        if (item && item.type === "curtain_wall") {
                            item.curtain.designData = data;
                            // Update item's direct properties from designData for easier access
                            item.curtain.wallWidth = data.wallWidth || 0;
                            item.curtain.wallHeight = data.wallHeight || 0;
                            item.curtain.cols = data.cols || 0;
                            item.curtain.rows = data.rows || 0;
                            item.curtain.frameMeters = data.frameMeters || 0;
                            item.curtain.windowMeters = data.windowMeters || 0;
                            item.curtain.glassArea = data.glassArea || 0;
                            item.curtain.cornerCount = data.cornerCount || 0;
                            item.curtain.panels = data.panels || [];

                            // Generate SVG here for display and submission
                            item.curtain.visualSvg =
                                generateCurtainWallSvg(data);
                        }

                        // Update the summary display
                        const shapeEl = itemElement.querySelector(
                            `#curtainWallShape-${itemId}`
                        );
                        if (shapeEl && item && item.curtain.visualSvg) {
                            shapeEl.innerHTML = item.curtain.visualSvg;
                        }

                        // Add a hidden input to store the design data for export
                        let hiddenInput = curtainSummary.querySelector(
                            'input[name="curtainWallData"]'
                        );
                        if (!hiddenInput) {
                            hiddenInput = document.createElement("input");
                            hiddenInput.type = "hidden";
                            hiddenInput.name = "curtainWallData";
                            curtainSummary.appendChild(hiddenInput);
                        }
                        hiddenInput.value = JSON.stringify(data);
                    }
                }
            });
            // FIXED: Profile enrichment helper with improved matching and data merging
            function enrichProfileData(profileData) {
                try {
                    if (!profileData) return profileData;

                    // Normalize profile identifiers for better matching
                    const code = (
                        profileData.profile_code ||
                        profileData.code ||
                        ""
                    )
                        .toString()
                        .trim();
                    const name = (
                        profileData.profile_name ||
                        profileData.name ||
                        ""
                    )
                        .toString()
                        .trim();
                    const brand = (profileData.Brand || profileData.brand || "")
                        .toString()
                        .trim();

                    if (!Array.isArray(profiles) || profiles.length === 0) {
                        console.warn("No profiles available for enrichment");
                        return profileData;
                    }

                    let sheetProfile = null;

                    // Try multiple matching strategies for better reliability
                    if (code) {
                        // First try exact code match
                        sheetProfile = profiles.find(
                            (p) => String(p.profile_code || "").trim() === code
                        );

                        // If no exact match, try case-insensitive
                        if (!sheetProfile) {
                            sheetProfile = profiles.find(
                                (p) =>
                                    String(p.profile_code || "")
                                        .trim()
                                        .toLowerCase() === code.toLowerCase()
                            );
                        }
                    }

                    // Try name matching if code didn't work
                    if (!sheetProfile && name) {
                        sheetProfile = profiles.find(
                            (p) => String(p.profile_name || "").trim() === name
                        );

                        if (!sheetProfile) {
                            sheetProfile = profiles.find(
                                (p) =>
                                    String(p.profile_name || "")
                                        .trim()
                                        .toLowerCase() === name.toLowerCase()
                            );
                        }
                    }

                    // Try brand + code combination if available
                    if (!sheetProfile && brand && code) {
                        sheetProfile = profiles.find(
                            (p) =>
                                String(p.Brand || "")
                                    .trim()
                                    .toLowerCase() === brand.toLowerCase() &&
                                String(p.profile_code || "")
                                    .trim()
                                    .toLowerCase() === code.toLowerCase()
                        );
                    }

                    if (!sheetProfile) {
                        console.warn(
                            "No matching profile found in sheet for:",
                            { code, name, brand }
                        );
                        return profileData;
                    }

                    console.log(
                        "Found matching profile:",
                        sheetProfile.profile_code,
                        sheetProfile.profile_name
                    );

                    // Create enriched profile with all necessary fields
                    const enriched = { ...profileData };

                    // Numeric fields that should be enriched from sheet data
                    const numericKeys = [
                        "frame_price",
                        "frame_price_3",
                        "leaf_price",
                        "accessories_2_leaves",
                        "accessories_3_leaves",
                        "accessories_4_leaves",
                        "glass_price_single",
                        "glass_price_double",
                        "arc_price",
                        "net_price",
                        "net_price_plisse",
                        "net_price_panda",
                        "base_profit_rate",
                        "max_h",
                        "max_w",
                    ];

                    numericKeys.forEach((k) => {
                        const curVal = Number(enriched[k]);
                        const sheetVal = Number(sheetProfile[k]);
                        const curHas = Number.isFinite(curVal) && curVal > 0;
                        const sheetHas =
                            Number.isFinite(sheetVal) && sheetVal > 0;

                        // Always prefer sheet data for numeric values
                        if (sheetHas) {
                            enriched[k] = sheetVal;
                        } else if (!curHas) {
                            enriched[k] = 0; // Set to 0 if neither has valid data
                        }
                    });

                    // String fields that should be enriched
                    const stringKeys = [
                        "Brand",
                        "brand",
                        "system",
                        "profile_name",
                        "profile_code",
                    ];
                    stringKeys.forEach((k) => {
                        if (sheetProfile[k]) {
                            enriched[k] = sheetProfile[k];
                        }
                    });

                    // Ensure consistent field naming
                    if (!enriched.profile_code && enriched.code)
                        enriched.profile_code = enriched.code;
                    if (!enriched.profile_name && enriched.name)
                        enriched.profile_name = enriched.name;
                    if (!enriched.Brand && enriched.brand)
                        enriched.Brand = enriched.brand;

                    // Backfill "price" field for compatibility
                    if (
                        (enriched.price == null ||
                            Number(enriched.price) === 0) &&
                        Number(enriched.frame_price)
                    ) {
                        enriched.price = enriched.frame_price;
                    }

                    return enriched;
                } catch (e) {
                    console.error("enrichProfileData error:", e);
                    return profileData;
                }
            }

            // PRICING CALCULATION FUNCTION - Based on n8n formula
            function calculatePricing() {
                updateItemsData(); // Ensure all data is up to date

                // Show loading state
                const calculateBtn = document.querySelector(".calculate-btn");
                const originalText = calculateBtn.innerHTML;
                calculateBtn.innerHTML =
                    '<i class="fas fa-spinner fa-spin"></i> Calculating...';
                calculateBtn.disabled = true;

                // Debug log for troubleshooting loaded quotes
                console.log("calculatePricing: Processing items:", items);

                try {
                    // Process items using the n8n pricing formula
                    const pricedItems = items.map((raw) => {
                        // Clone so we don't mutate original input object
                        const item = JSON.parse(JSON.stringify(raw));

                        // Quantity - handle both new items and loaded quotes
                        const qty = Number(
                            item.quantity ||
                                item.curtain?.quantity ||
                                (item.type === "curtain_wall"
                                    ? 1
                                    : item.quantity) ||
                                1
                        );

                        // Normalize profile fields into item.profile with proper fallback for loaded quotes
                        const profileData = enrichProfileData(
                            item.profile || item.curtain?.profile || {}
                        );

                        // For loaded quotes, ensure we have the profile data structure
                        if (!item.profile && item.curtain?.profile) {
                            item.profile = item.curtain.profile;
                        }

                        item.profile = {
                            profile_code:
                                profileData.profile_code ||
                                profileData.code ||
                                "",
                            brand: profileData.Brand || profileData.brand || "",
                            profile_name:
                                profileData.profile_name ||
                                profileData.name ||
                                "",
                            frame_price: Number(
                                profileData.frame_price ||
                                    profileData.price ||
                                    0
                            ),
                            frame_price_3: Number(
                                profileData.frame_price_3 || 0
                            ),
                            leaf_price: Number(profileData.leaf_price || 0),
                            accessories_2_leaves: Number(
                                profileData.accessories_2_leaves || 0
                            ),
                            accessories_3_leaves: Number(
                                profileData.accessories_3_leaves || 0
                            ),
                            accessories_4_leaves: Number(
                                profileData.accessories_4_leaves || 0
                            ),
                            glass_price_single: Number(
                                profileData.glass_price_single || 0
                            ),
                            glass_price_double: Number(
                                profileData.glass_price_double || 0
                            ),
                            arc_price: Number(profileData.arc_price || 0),
                            net_price: Number(profileData.net_price || 0),
                            net_price_plisse: Number(
                                profileData.net_price_plisse || 0
                            ),
                            net_price_panda: Number(
                                profileData.net_price_panda || 0
                            ),
                            base_profit_rate: Number(
                                profileData.base_profit_rate || 0
                            ), // Default 0 if not specified (n8n parity)
                        };

                        const p = item.profile;

                        // CURTAIN WALL: FIXED LOGIC
                        if (item.type === "curtain_wall") {
                            // Safe numeric extraction with proper fallback chain for loaded quotes
                            const frameMeters = Number(
                                item.frameMeters ||
                                    item.curtain?.frameMeters ||
                                    item.curtain?.designData?.frameMeters ||
                                    item.designData?.frameMeters ||
                                    0
                            );
                            const windowMeters = Number(
                                item.windowMeters ||
                                    item.curtain?.windowMeters ||
                                    item.curtain?.designData?.windowMeters ||
                                    item.designData?.windowMeters ||
                                    0
                            );
                            const glassArea = Number(
                                item.glassArea ||
                                    item.curtain?.glassArea ||
                                    item.curtain?.designData?.glassArea ||
                                    item.designData?.glassArea ||
                                    0
                            );

                            // Panels array -> count windows & doors safely with proper fallback chain
                            const panels = Array.isArray(item.curtain?.panels)
                                ? item.curtain.panels
                                : Array.isArray(
                                      item.curtain?.designData?.panels
                                  )
                                ? item.curtain.designData.panels
                                : Array.isArray(item.designData?.panels)
                                ? item.designData.panels
                                : Array.isArray(item.panels)
                                ? item.panels
                                : [];
                            const numWindows = panels.filter(
                                (pl) =>
                                    String(pl?.type).toLowerCase() === "window"
                            ).length;
                            const numDoors = panels.filter(
                                (pl) =>
                                    String(pl?.type).toLowerCase() === "door"
                            ).length;
                            const cornerCount = Number(
                                item.curtain?.cornerCount ||
                                    item.curtain?.designData?.cornerCount ||
                                    item.designData?.cornerCount ||
                                    item.cornerCount ||
                                    0
                            );

                            // Area is always glass m
                            const totalAreaUnit = glassArea;

                            // Determine per-meter rates
                            const framePricePerMeter = Number(
                                item.curtain?.frameProfile?.frame_price ||
                                    item.curtain?.frameProfile?.price ||
                                    p.frame_price ||
                                    0
                            );

                            const windowPricePerMeter = Number(
                                item.curtain?.windowProfile?.frame_price ||
                                    item.curtain?.windowProfile?.price ||
                                    p.leaf_price ||
                                    0
                            );

                            // Accessory unit prices
                            const accessoriesPerWindowDoor =
                                p.accessories_2_leaves || 0;
                            const frameAccessoriesPerMeter =
                                p.accessories_3_leaves || 0;
                            const cornerAccessory = p.accessories_4_leaves || 0;

                            // Component costs
                            const frameCostUnit =
                                framePricePerMeter * frameMeters;
                            const windowsCostUnit =
                                windowPricePerMeter * windowMeters;
                            const accessoriesWinDoorUnit =
                                (numWindows + numDoors) *
                                accessoriesPerWindowDoor;
                            const frameAccessoriesUnit =
                                frameMeters * frameAccessoriesPerMeter;
                            const cornersUnit = cornerCount * cornerAccessory;

                            // Subtotal before profit
                            const totalBeforeProfitUnit =
                                frameCostUnit +
                                windowsCostUnit +
                                accessoriesWinDoorUnit +
                                frameAccessoriesUnit +
                                cornersUnit;

                            // Profit calculation
                            let profitRate = Number(p.base_profit_rate || 0);

                            // Add extra 0.1 per m above 4 (like doors/windows)
                            const extraArea =
                                totalAreaUnit > 4
                                    ? Math.ceil(totalAreaUnit - 4)
                                    : 0;
                            profitRate += extraArea * 0.1;

                            const profitAmountUnit =
                                profitRate * totalBeforeProfitUnit;
                            const totalPriceUnit =
                                totalBeforeProfitUnit + profitAmountUnit;

                            const denomArea =
                                totalAreaUnit > 0 ? totalAreaUnit : 1;

                            return {
                                ...item,
                                quantity: qty,
                                frameMeters,
                                windowMeters,
                                glassArea,
                                totalArea: totalAreaUnit,
                                numWindows,
                                numDoors,
                                cornerCount,

                                // Breakdown
                                frameCost: +(frameCostUnit * qty).toFixed(2),
                                windowsCost: +(windowsCostUnit * qty).toFixed(
                                    2
                                ),
                                accessoriesWindowsDoors: +(
                                    accessoriesWinDoorUnit * qty
                                ).toFixed(2),
                                frameAccessories: +(
                                    frameAccessoriesUnit * qty
                                ).toFixed(2),
                                cornersCost: +(cornersUnit * qty).toFixed(2),

                                // Totals
                                totalBeforeProfit: +(
                                    totalBeforeProfitUnit * qty
                                ).toFixed(2),
                                base_profit_rate: +profitRate.toFixed(4),
                                profitAmount: +(profitAmountUnit * qty).toFixed(
                                    2
                                ),
                                totalPrice: +(totalPriceUnit * qty).toFixed(2),

                                // Derived metrics
                                m2Price: +(totalPriceUnit / denomArea).toFixed(
                                    2
                                ),
                                profitPercentage: +(
                                    totalPriceUnit
                                        ? (profitAmountUnit / totalPriceUnit) *
                                          100
                                        : 0
                                ).toFixed(2),
                                area: +(totalAreaUnit * qty).toFixed(2),

                                // Keep these for compatibility
                                netCost: 0,
                                archCost: 0,
                                frameLength: 0,
                                leafPerimeter: 0,
                                totalLeafLength: 0,
                            };
                        }

                        // DOORS + WINDOWS (unchanged)
                        const originalWidth = Number(item.width);
                        const originalHeight = Number(item.height);
                        const leaves = Number(item.leaves) || 1;

                        const calcWidth = originalWidth < 1 ? 1 : originalWidth;
                        const calcHeight =
                            originalHeight < 1 ? 1 : originalHeight;

                        const areaUnit = calcWidth * calcHeight;
                        const frameLengthUnit = 2 * (calcWidth + calcHeight);
                        const leafPerimeter =
                            2 * (calcWidth / leaves + calcHeight);
                        const totalLeafLengthUnit = leafPerimeter * leaves;

                        let accessoriesUnit = 0;
                        if (leaves === 2)
                            accessoriesUnit = p.accessories_2_leaves;
                        else if (leaves === 3)
                            accessoriesUnit = p.accessories_3_leaves;
                        else if (leaves === 4)
                            accessoriesUnit = p.accessories_4_leaves;

                        const selectedFramePrice =
                            leaves === 3 ? p.frame_price_3 : p.frame_price;
                        const frameCostUnit =
                            selectedFramePrice * frameLengthUnit;
                        const leafCostUnit = p.leaf_price * totalLeafLengthUnit;

                        const glassType =
                            item.glassType?.toLowerCase() || "single";
                        const glassRate =
                            glassType === "double"
                                ? p.glass_price_double
                                : p.glass_price_single;
                        const glassCostUnit = glassRate * areaUnit;

                        let netCostUnit = 0;
                        if (
                            item.system?.toLowerCase() === "hinged" &&
                            item.mosquito
                        ) {
                            const netType = item.netType?.toLowerCase() || "";
                            if (netType === "fixed") {
                                netCostUnit = p.net_price * leafPerimeter;
                            } else if (netType === "plisse") {
                                netCostUnit =
                                    p.net_price_plisse * leafPerimeter;
                            } else if (netType === "panda") {
                                netCostUnit = p.net_price_panda * leafPerimeter;
                            }
                        }

                        let archMultiplier = 4;
                        if (item.type === "door") archMultiplier = 3;
                        const archCostUnit = item.arch
                            ? p.arc_price * archMultiplier
                            : 0;

                        const totalBeforeProfitUnit =
                            accessoriesUnit +
                            frameCostUnit +
                            leafCostUnit +
                            glassCostUnit +
                            netCostUnit +
                            archCostUnit;
                        let profitRate = Number(p.base_profit_rate || 0);
                        const extraArea =
                            areaUnit > 4 ? Math.ceil(areaUnit - 4) : 0;
                        profitRate += extraArea * 0.1;

                        const profitAmountUnit =
                            profitRate * totalBeforeProfitUnit;
                        const totalPriceUnit =
                            totalBeforeProfitUnit + profitAmountUnit;

                        return {
                            ...item,
                            quantity: qty,
                            width: originalWidth,
                            height: originalHeight,
                            frameLength: +(frameLengthUnit * qty).toFixed(2),
                            leafPerimeter: +leafPerimeter.toFixed(2),
                            totalLeafLength: +(
                                totalLeafLengthUnit * qty
                            ).toFixed(2),
                            area: +(areaUnit * qty).toFixed(2),
                            accessories: +(accessoriesUnit * qty).toFixed(2),
                            frameCost: +(frameCostUnit * qty).toFixed(2),
                            leafCost: +(leafCostUnit * qty).toFixed(2),
                            glassCost: +(glassCostUnit * qty).toFixed(2),
                            netCost: +(netCostUnit * qty).toFixed(2),
                            archCost: +(archCostUnit * qty).toFixed(2),
                            totalBeforeProfit: +(
                                totalBeforeProfitUnit * qty
                            ).toFixed(2),
                            base_profit_rate: +profitRate.toFixed(2),
                            profitAmount: +(profitAmountUnit * qty).toFixed(2),
                            totalPrice: +(totalPriceUnit * qty).toFixed(2),
                            m2Price: +(
                                totalPriceUnit / (areaUnit || 1)
                            ).toFixed(2),
                            profitPercentage: +(
                                (profitAmountUnit / totalPriceUnit) *
                                100
                            ).toFixed(2),
                        };
                    });

                    // Calculate totals
                    const totalM2 = pricedItems.reduce(
                        (sum, i) => sum + Number(i.area || 0),
                        0
                    );
                    const totalBefore = pricedItems.reduce(
                        (sum, i) => sum + Number(i.totalBeforeProfit || 0),
                        0
                    );
                    const totalAfter = pricedItems.reduce(
                        (sum, i) => sum + Number(i.totalPrice || 0),
                        0
                    );
                    const totalProfit = totalAfter - totalBefore;
                    const totalProfitPercentage = totalAfter
                        ? (totalProfit / totalAfter) * 100
                        : 0;
                    const totalM2Price = totalM2 ? totalAfter / totalM2 : 0;
                    const downPayment = totalAfter * 0.8;
                    const supplyPayment = totalAfter * 0.1;
                    const completePayment = totalAfter * 0.1;

                    // Display the pricing breakdown
                    displayPricingBreakdown(pricedItems, {
                        totalM2: +totalM2.toFixed(2),
                        totalBefore: +totalBefore.toFixed(2),
                        totalAfter: +totalAfter.toFixed(2),
                        totalProfit: +totalProfit.toFixed(2),
                        totalProfitPercentage:
                            +totalProfitPercentage.toFixed(2),
                        totalM2Price: +totalM2Price.toFixed(2),
                        downPayment: +downPayment.toFixed(2),
                        supplyPayment: +supplyPayment.toFixed(2),
                        completePayment: +completePayment.toFixed(2),
                    });
                } catch (error) {
                    console.error("Error calculating pricing:", error);
                    alert(
                        "Error calculating pricing. Please check that all items have profiles selected."
                    );
                } finally {
                    // Restore button state
                    calculateBtn.innerHTML = originalText;
                    calculateBtn.disabled = false;
                }
            }

            // Build a verbose "how it was calculated" HTML block per item
            function buildPricingExplanationHtml(item) {
                try {
                    const fmt = (n) => Number(n ?? 0).toLocaleString();
                    const pct = (n) => (Number(n ?? 0) * 100).toFixed(2) + "%";
                    let html =
                        '<details class="pricing-explain" style="margin-top:10px;"><summary style="cursor:pointer;font-weight:600;color:#A72036;">How this was calculated</summary><div style="margin-top:10px;font-size:0.9rem;">';
                    if ((item.type || "").toLowerCase() === "curtain_wall") {
                        const p = item.profile || {};
                        const baseRate = Number(p.base_profit_rate || 0);
                        const extraArea = Math.max(
                            0,
                            Math.ceil(Number(item.glassArea || 0) - 4)
                        );
                        const profitRate = baseRate + extraArea * 0.1;
                        html += `
                        <div>Inputs</div>
                        <ul>
                            <li>Frame meters: ${fmt(item.frameMeters)}</li>
                            <li>Window/Door meters: ${fmt(
                                item.windowMeters
                            )}</li>
                            <li>Glass area: ${fmt(item.glassArea)} m</li>
                            <li>Windows: ${fmt(item.numWindows)}, Doors: ${fmt(
                            item.numDoors
                        )}, Corners: ${fmt(item.cornerCount)}</li>
                        </ul>
                        <div>Rates</div>
                        <ul>
                            <li>Frame price per meter: ${fmt(
                                p.frame_price
                            )} EGP</li>
                            <li>Window/Door price per meter: ${fmt(
                                p.leaf_price
                            )} EGP</li>
                            <li>Accessories per window/door: ${fmt(
                                p.accessories_2_leaves
                            )} EGP</li>
                            <li>Frame accessories per meter: ${fmt(
                                p.accessories_3_leaves
                            )} EGP</li>
                            <li>Corner accessory per corner: ${fmt(
                                p.accessories_4_leaves
                            )} EGP</li>
                        </ul>
                        <div>Unit calculations (before quantity)</div>
                        <ul>
                            <li>Frame cost = frameMeters  frame_price = ${fmt(
                                item.frameMeters
                            )}  ${fmt(p.frame_price)} = ${fmt(
                            Number(item.frameMeters || 0) *
                                Number(p.frame_price || 0)
                        )} EGP</li>
                            <li>Windows cost = windowMeters  leaf_price = ${fmt(
                                item.windowMeters
                            )}  ${fmt(p.leaf_price)} = ${fmt(
                            Number(item.windowMeters || 0) *
                                Number(p.leaf_price || 0)
                        )} EGP</li>
                            <li>Accessories (windows/doors) = (windows + doors)  accessories_2_leaves = (${fmt(
                                item.numWindows
                            )} + ${fmt(item.numDoors)})  ${fmt(
                            p.accessories_2_leaves
                        )} = ${fmt(
                            (Number(item.numWindows || 0) +
                                Number(item.numDoors || 0)) *
                                Number(p.accessories_2_leaves || 0)
                        )} EGP</li>
                            <li>Frame accessories = frameMeters  accessories_3_leaves = ${fmt(
                                item.frameMeters
                            )}  ${fmt(p.accessories_3_leaves)} = ${fmt(
                            Number(item.frameMeters || 0) *
                                Number(p.accessories_3_leaves || 0)
                        )} EGP</li>
                            <li>Corners = cornerCount  accessories_4_leaves = ${fmt(
                                item.cornerCount
                            )}  ${fmt(p.accessories_4_leaves)} = ${fmt(
                            Number(item.cornerCount || 0) *
                                Number(p.accessories_4_leaves || 0)
                        )} EGP</li>
                        </ul>
                        <div>Profit</div>
                        <ul>
                            <li>Base profit rate: ${pct(baseRate)}</li>
                            <li>Extra area above 4 m: ceil(glassArea - 4) = ${fmt(
                                extraArea
                            )}  added ${(extraArea * 0.1).toFixed(
                            2
                        )} to rate</li>
                            <li>Final profit rate: ${(profitRate * 100).toFixed(
                                2
                            )}%</li>
                        </ul>
                        <div>Totals</div>
                        <ul>
                            <li>Subtotal (unit) = ${fmt(
                                Number(item.totalBeforeProfit || 0) /
                                    Number(item.quantity || 1)
                            )} EGP</li>
                            <li>Profit (unit) = ${fmt(
                                Number(item.profitAmount || 0) /
                                    Number(item.quantity || 1)
                            )} EGP</li>
                            <li>Quantity = ${fmt(item.quantity || 1)}</li>
                            <li>Total price = ${fmt(
                                item.totalPrice || 0
                            )} EGP</li>
                            <li>Price per m = ${fmt(
                                item.m2Price || 0
                            )} EGP/m</li>
                        </ul>
                    `;
                    } else {
                        const p = item.profile || {};
                        const baseRate = Number(p.base_profit_rate || 0);
                        const areaUnit =
                            Number(item.area || 0) /
                                Number(item.quantity || 1) || 0;
                        const extraArea =
                            areaUnit > 4 ? Math.ceil(areaUnit - 4) : 0;
                        const profitRate = baseRate + extraArea * 0.1;
                        const netLine =
                            Number(item.netCost || 0) > 0
                                ? `<li>Net cost = leafPerimeter  net price = ${fmt(
                                      item.leafPerimeter
                                  )}  ${fmt(
                                      p.net_price ||
                                          p.net_price_plisse ||
                                          p.net_price_panda ||
                                          0
                                  )} = ${fmt(
                                      Number(item.netCost || 0) /
                                          Number(item.quantity || 1)
                                  )} EGP (unit)</li>`
                                : "";
                        const archLine = item.arch
                            ? `<li>Arch cost = arc_price  ${
                                  item.type === "door" ? "3" : "4"
                              } = ${fmt(p.arc_price)}  ${
                                  item.type === "door" ? "3" : "4"
                              } = ${fmt(
                                  Number(item.archCost || 0) /
                                      Number(item.quantity || 1)
                              )} EGP (unit)</li>`
                            : "";
                        const glassRate =
                            String(item.glassType || "single").toLowerCase() ===
                            "double"
                                ? Number(p.glass_price_double || 0)
                                : Number(p.glass_price_single || 0);
                        html += `
                        <div>Inputs</div>
                        <ul>
                            <li>Width  Height = ${fmt(item.width)} m  ${fmt(
                            item.height
                        )} m</li>
                            <li>Area (unit) = ${fmt(areaUnit)} m</li>
                            <li>Leaves = ${fmt(item.leaves)}</li>
                            <li>Leaf perimeter (unit) = ${fmt(
                                item.leafPerimeter
                            )} m</li>
                            <li>Total leaf length (unit) = ${fmt(
                                item.totalLeafLength
                            )} m</li>
                        </ul>
                        <div>Rates</div>
                        <ul>
                            <li>Frame price (perimeter) = ${fmt(
                                item.leaves === 3
                                    ? p.frame_price_3
                                    : p.frame_price
                            )} EGP</li>
                            <li>Leaf price per meter = ${fmt(
                                p.leaf_price
                            )} EGP</li>
                            <li>Glass rate (${String(
                                item.glassType || "single"
                            ).toLowerCase()}) = ${fmt(glassRate)} EGP/m</li>
                            <li>Accessories (by leaves) = ${fmt(
                                item.leaves === 2
                                    ? p.accessories_2_leaves
                                    : item.leaves === 3
                                    ? p.accessories_3_leaves
                                    : p.accessories_4_leaves
                            )} EGP</li>
                        </ul>
                        <div>Unit calculations (before quantity)</div>
                        <ul>
                            <li>Frame cost = frameLength  frame_price = ${fmt(
                                Number(item.frameLength || 0) /
                                    Number(item.quantity || 1)
                            )}  ${fmt(
                            item.leaves === 3 ? p.frame_price_3 : p.frame_price
                        )} = ${fmt(
                            Number(item.frameCost || 0) /
                                Number(item.quantity || 1)
                        )} EGP</li>
                            <li>Leaf cost = totalLeafLength  leaf_price = ${fmt(
                                Number(item.totalLeafLength || 0) /
                                    Number(item.quantity || 1)
                            )}  ${fmt(p.leaf_price)} = ${fmt(
                            Number(item.leafCost || 0) /
                                Number(item.quantity || 1)
                        )} EGP</li>
                            <li>Glass cost = area  glass_rate = ${fmt(
                                areaUnit
                            )}  ${fmt(glassRate)} = ${fmt(
                            Number(item.glassCost || 0) /
                                Number(item.quantity || 1)
                        )} EGP</li>
                            ${netLine}
                            ${archLine}
                        </ul>
                        <div>Profit</div>
                        <ul>
                            <li>Base profit rate: ${pct(baseRate)}</li>
                            <li>Extra area above 4 m: ceil(area - 4) = ${fmt(
                                extraArea
                            )}  added ${(extraArea * 0.1).toFixed(
                            2
                        )} to rate</li>
                            <li>Final profit rate: ${(profitRate * 100).toFixed(
                                2
                            )}%</li>
                        </ul>
                    `;
                    }
                    html += "</div></details>";
                    return html;
                } catch (e) {
                    return "";
                }
            }

            // Display pricing breakdown
            function displayPricingBreakdown(pricedItems, totals) {
                const pricingBreakdown =
                    document.getElementById("pricing-breakdown");
                const pricingItems = document.getElementById("pricing-items");

                // Clear existing content
                pricingItems.innerHTML = "";

                // Add individual item pricing
                pricedItems.forEach((item, index) => {
                    const itemDiv = document.createElement("div");
                    itemDiv.className = "item-pricing";

                    let itemContent = `
                    <h4>Item #${index + 1}: ${
                        item.type.charAt(0).toUpperCase() + item.type.slice(1)
                    } (ID: ${item.uniqueId})</h4>
                `;

                    if (item.type === "curtain_wall") {
                        itemContent += `
                        <div class="pricing-detail"><span>Dimensions:</span><span>${
                            item.curtain?.wallWidth || 0
                        }m  ${item.curtain?.wallHeight || 0}m</span></div>
                        <div class="pricing-detail"><span>Glass Area:</span><span>${
                            item.glassArea || 0
                        } m</span></div>
                        <div class="pricing-detail"><span>Frame Cost:</span><span>${
                            item.frameCost || 0
                        } EGP</span></div>
                        <div class="pricing-detail"><span>Windows Cost:</span><span>${
                            item.windowsCost || 0
                        } EGP</span></div>
                        <div class="pricing-detail"><span>Accessories:</span><span>${
                            item.accessoriesWindowsDoors || 0
                        } EGP</span></div>
                        <div class="pricing-detail"><span>Frame Accessories:</span><span>${
                            item.frameAccessories || 0
                        } EGP</span></div>
                        <div class="pricing-detail"><span>Corners:</span><span>${
                            item.cornersCost || 0
                        } EGP</span></div>
                    `;
                    } else {
                        itemContent += `
                        <div class="pricing-detail"><span>Dimensions:</span><span>${
                            item.width
                        }m  ${item.height}m</span></div>
                        <div class="pricing-detail"><span>Area:</span><span>${
                            item.area
                        } m</span></div>
                        <div class="pricing-detail"><span>Frame Cost:</span><span>${
                            item.frameCost || 0
                        } EGP</span></div>
                        <div class="pricing-detail"><span>Leaf Cost:</span><span>${
                            item.leafCost || 0
                        } EGP</span></div>
                        <div class="pricing-detail"><span>Glass Cost:</span><span>${
                            item.glassCost || 0
                        } EGP</span></div>
                        <div class="pricing-detail"><span>Accessories:</span><span>${
                            item.accessories || 0
                        } EGP</span></div>
                        ${
                            item.netCost
                                ? `<div class="pricing-detail"><span>Net Cost:</span><span>${item.netCost} EGP</span></div>`
                                : ""
                        }
                        ${
                            item.archCost
                                ? `<div class="pricing-detail"><span>Arch Cost:</span><span>${item.archCost} EGP</span></div>`
                                : ""
                        }
                    `;
                    }

                    itemContent += `
                    <div class="pricing-detail"><span>Subtotal:</span><span>${
                        item.totalBeforeProfit
                    } EGP</span></div>
                    <div class="pricing-detail"><span>Profit (${
                        item.base_profit_rate
                            ? (item.base_profit_rate * 100).toFixed(1)
                            : 0
                    }%):</span><span>${item.profitAmount} EGP</span></div>
                    <div class="pricing-detail total"><span>Total Price:</span><span>${
                        item.totalPrice
                    } EGP</span></div>
                    <div class="pricing-detail"><span>Price per m:</span><span>${
                        item.m2Price
                    } EGP/m</span></div>
                `;

                    itemDiv.innerHTML = itemContent;
                    const explainHtml = buildPricingExplanationHtml(item);
                    if (explainHtml) {
                        itemDiv.insertAdjacentHTML("beforeend", explainHtml);
                    }
                    pricingItems.appendChild(itemDiv);
                });

                // Update totals
                document.getElementById(
                    "total-area"
                ).textContent = `${totals.totalM2} m`;
                document.getElementById(
                    "total-before-profit"
                ).textContent = `${totals.totalBefore.toLocaleString()} EGP`;
                document.getElementById(
                    "total-profit"
                ).textContent = `${totals.totalProfit.toLocaleString()} EGP`;
                document.getElementById(
                    "average-profit-rate"
                ).textContent = `${totals.totalProfitPercentage.toFixed(1)}%`;
                document.getElementById(
                    "price-per-m2"
                ).textContent = `${totals.totalM2Price.toLocaleString()} EGP/m`;
                document.getElementById(
                    "total-project-value"
                ).textContent = `${totals.totalAfter.toLocaleString()} EGP`;

                // Update payment schedule
                document.getElementById(
                    "down-payment"
                ).textContent = `${totals.downPayment.toLocaleString()} EGP`;
                document.getElementById(
                    "supply-payment"
                ).textContent = `${totals.supplyPayment.toLocaleString()} EGP`;
                document.getElementById(
                    "completion-payment"
                ).textContent = `${totals.completePayment.toLocaleString()} EGP`;

                // Show the pricing breakdown
                pricingBreakdown.style.display = "block";

                // Scroll to pricing breakdown
                pricingBreakdown.scrollIntoView({ behavior: "smooth" });
            }

            // SAVE QUOTE FUNCTIONALITY
            function showSaveDialog() {
                // Validate that we have items and contact info
                updateItemsData();

                if (items.length === 0) {
                    alert(
                        "Please add at least one item before saving the quote."
                    );
                    return;
                }

                // Check if contact info is filled
                const contactName = document
                    .getElementById("contact-name")
                    .value.trim();
                if (!contactName) {
                    alert(
                        "Please fill in the contact information before saving the quote."
                    );
                    return;
                }

                // Generate a default name based on project type and date
                const projectType =
                    document.querySelector('input[name="projectType"]:checked')
                        ?.value || "project";
                const today = new Date().toLocaleDateString();
                const defaultName = `${
                    projectType.charAt(0).toUpperCase() + projectType.slice(1)
                } Quote - ${today}`;

                document.getElementById("quoteName").value = defaultName;
                document.getElementById("quoteDescription").value = "";
                document.getElementById("saveModal").classList.add("active");
            }

            function closeSaveDialog() {
                document.getElementById("saveModal").classList.remove("active");
            }

            function confirmSaveQuote() {
                const quoteName = document
                    .getElementById("quoteName")
                    .value.trim();
                const quoteDescription = document
                    .getElementById("quoteDescription")
                    .value.trim();

                if (!quoteName) {
                    alert("Please enter a name for the quote.");
                    return;
                }

                // Generate unique quote ID
                const quoteId = generateQuoteId();

                // Prepare quote data
                const quoteData = {
                    id: quoteId,
                    name: quoteName,
                    description: quoteDescription,
                    projectType:
                        document.querySelector(
                            'input[name="projectType"]:checked'
                        )?.value || "",
                    contactInfo: {
                        name: document.getElementById("contact-name").value,
                        phone: document.getElementById("contact-phone").value,
                        email: document.getElementById("contact-email").value,
                        method:
                            document.querySelector(
                                'input[name="contactMethod"]:checked'
                            )?.value || "",
                        location:
                            document.getElementById("contact-location").value,
                        notes: document.getElementById("contact-notes").value,
                    },
                    items: items.map((item) => {
                        if (item.type === "curtain_wall") {
                            return {
                                id: item.uniqueId,
                                type: item.type,
                                quantity: item.curtain.quantity,
                                glassType: item.curtain.glassType || "double",
                                profile: item.curtain.profile
                                    ? {
                                          code: item.curtain.profile
                                              .profile_code,
                                          name: item.curtain.profile
                                              .profile_name,
                                          brand: item.curtain.profile.Brand,
                                          price: item.curtain.profile
                                              .frame_price,
                                      }
                                    : null,
                                designData: item.curtain.designData,
                                visualSvg: item.curtain.visualSvg,
                            };
                        } else {
                            return {
                                id: item.uniqueId,
                                type: item.type,
                                width: item.width,
                                height: item.height,
                                quantity: item.quantity,
                                leaves: item.leaves,
                                system: item.system,
                                glassType: item.glassType,
                                profile: item.profile
                                    ? {
                                          code: item.profile.profile_code,
                                          name: item.profile.profile_name,
                                          brand: item.profile.Brand,
                                          price: item.profile.frame_price,
                                      }
                                    : null,
                                color: item.color,
                                glassAppearance: item.glassAppearance,
                                argon: item.argon,
                                mosquito: item.mosquito,
                                netType: item.netType,
                                arch: item.arch,
                            };
                        }
                    }),
                    createdAt: new Date().toISOString(),
                    lastModified: new Date().toISOString(),
                };

                // Save to localStorage
                saveQuoteToStorage(quoteData);

                // Close dialog
                closeSaveDialog();

                // Show success notification
                showSuccessNotification(
                    `Quote "${quoteName}" saved successfully!`
                );
            }

            async function saveQuoteToStorage(quoteData) {
                try {
                    // Check if Firebase is available
                    if (FirebaseDB && FirebaseDB.Quotes) {
                        // Save to Firebase
                        await FirebaseDB.Quotes.saveQuote(quoteData);
                        console.log(
                            "Quote saved to Firebase successfully:",
                            quoteData.id
                        );
                    } else {
                        console.warn(
                            "Firebase not available, falling back to localStorage"
                        );
                        // Fallback to localStorage
                        const existingQuotes = JSON.parse(
                            localStorage.getItem("cocoonQuotes") || "[]"
                        );

                        // Check if quote with same ID exists (for updates)
                        const existingIndex = existingQuotes.findIndex(
                            (q) => q.id === quoteData.id
                        );

                        if (existingIndex >= 0) {
                            // Update existing quote
                            quoteData.lastModified = new Date().toISOString();
                            existingQuotes[existingIndex] = quoteData;
                        } else {
                            // Add new quote
                            existingQuotes.push(quoteData);
                        }

                        // Sort by creation date (newest first)
                        existingQuotes.sort(
                            (a, b) =>
                                new Date(b.createdAt) - new Date(a.createdAt)
                        );

                        // Save back to localStorage
                        localStorage.setItem(
                            "cocoonQuotes",
                            JSON.stringify(existingQuotes)
                        );

                        console.log(
                            "Quote saved to localStorage fallback:",
                            quoteData.id
                        );
                    }
                } catch (error) {
                    console.error("Error saving quote:", error);
                    // Fallback to localStorage if Firebase fails
                    try {
                        const existingQuotes = JSON.parse(
                            localStorage.getItem("cocoonQuotes") || "[]"
                        );

                        const existingIndex = existingQuotes.findIndex(
                            (q) => q.id === quoteData.id
                        );

                        if (existingIndex >= 0) {
                            quoteData.lastModified = new Date().toISOString();
                            existingQuotes[existingIndex] = quoteData;
                        } else {
                            existingQuotes.push(quoteData);
                        }

                        existingQuotes.sort(
                            (a, b) =>
                                new Date(b.createdAt) - new Date(a.createdAt)
                        );
                        localStorage.setItem(
                            "cocoonQuotes",
                            JSON.stringify(existingQuotes)
                        );

                        console.log(
                            "Quote saved to localStorage fallback after error:",
                            quoteData.id
                        );
                    } catch (fallbackError) {
                        console.error(
                            "Error in localStorage fallback:",
                            fallbackError
                        );
                        alert("Error saving quote. Please try again.");
                    }
                }
            }

            function showSuccessNotification(message) {
                const notification = document.getElementById(
                    "successNotification"
                );
                const textElement = document.getElementById("notificationText");

                textElement.textContent = message;
                notification.classList.add("active");

                // Auto-hide after 3 seconds
                setTimeout(() => {
                    notification.classList.remove("active");
                }, 3000);
            }

            function openQuotesHistory() {
                // Open the quotes history page in a new tab
                window.open("dashboard.html", "_blank");
            }

            // FIXED: Function to load a saved quote with improved error handling and user feedback
            function loadSavedQuote(quoteId) {
                try {
                    console.log("Loading quote with ID:", quoteId);

                    // Set loading flag to prevent alert messages during profile selection
                    window.isLoadingQuote = true;

                    // Validate quote ID
                    if (!quoteId || typeof quoteId !== "string") {
                        throw new Error("Invalid quote ID provided");
                    }

                    const savedQuotes = JSON.parse(
                        localStorage.getItem("cocoonQuotes") || "[]"
                    );
                    const quote = savedQuotes.find((q) => q.id === quoteId);

                    if (!quote) {
                        console.error("Quote not found:", quoteId);
                        console.log(
                            "Available quotes:",
                            savedQuotes.map((q) => ({ id: q.id, name: q.name }))
                        );
                        alert(
                            "Quote not found. It may have been deleted or the ID is incorrect."
                        );
                        window.isLoadingQuote = false;
                        return;
                    }

                    console.log("Found quote:", {
                        id: quote.id,
                        name: quote.name,
                        itemCount: quote.items?.length || 0,
                    });

                    // Validate quote structure
                    if (!quote.items || !Array.isArray(quote.items)) {
                        console.warn(
                            "Quote has invalid or missing items array:",
                            quote
                        );
                        quote.items = []; // Initialize empty items array
                    }

                    if (!quote.contactInfo) {
                        console.warn("Quote has missing contact info:", quote);
                        quote.contactInfo = {}; // Initialize empty contact info
                    }

                    // Show loading notification
                    showSuccessNotification(`Loading quote "${quote.name}"...`);

                    // Reset form first
                    resetFormForQuoteLoad();

                    // Wait for form to reset and profiles to be available
                    const waitForProfilesAndLoad = () => {
                        if (profiles && profiles.length > 0) {
                            console.log(
                                `Profiles available (${profiles.length}), proceeding with quote load`
                            );

                            setTimeout(() => {
                                try {
                                    loadQuoteData(quote);
                                } catch (innerError) {
                                    console.error(
                                        "Error in quote loading process:",
                                        innerError
                                    );
                                    alert(
                                        "Error loading quote data: " +
                                            innerError.message
                                    );
                                    window.isLoadingQuote = false;
                                }
                            }, 500);
                        } else {
                            console.log("Waiting for profiles to load...");
                            setTimeout(waitForProfilesAndLoad, 500);
                        }
                    };

                    // Start the loading process
                    waitForProfilesAndLoad();
                } catch (error) {
                    console.error("Error loading quote:", error);
                    alert("Error loading quote: " + error.message);
                    window.isLoadingQuote = false;
                }
            }

            // Separate function to reset form specifically for quote loading
            function resetFormForQuoteLoad() {
                // Clear existing items
                document.getElementById("items-container").innerHTML = "";
                items = [];
                itemCount = 0;

                // Reset to first step
                document
                    .querySelectorAll(".form-section")
                    .forEach((section) => {
                        section.classList.remove("active");
                    });
                document.getElementById("step1").classList.add("active");
                currentStep = 1;

                // Reset progress bar
                document
                    .querySelectorAll(".progress-step")
                    .forEach((el, index) => {
                        if (index === 0) {
                            el.classList.add("active");
                        } else {
                            el.classList.remove("active");
                        }
                    });
            }

            // Function to load quote data into the form
            function loadQuoteData(quote) {
                // Load project type
                const projectTypeRadio = document.querySelector(
                    `input[name="projectType"][value="${quote.projectType}"]`
                );
                if (projectTypeRadio) {
                    projectTypeRadio.checked = true;
                }

                // Load contact info
                if (quote.contactInfo) {
                    const contactFields = {
                        "contact-name": quote.contactInfo.name || "",
                        "contact-phone": quote.contactInfo.phone || "",
                        "contact-email": quote.contactInfo.email || "",
                        "contact-location": quote.contactInfo.location || "",
                        "contact-notes": quote.contactInfo.notes || "",
                    };

                    Object.entries(contactFields).forEach(
                        ([fieldId, value]) => {
                            const field = document.getElementById(fieldId);
                            if (field) field.value = value;
                        }
                    );

                    // Load contact method
                    const contactMethodRadio = document.querySelector(
                        `input[name="contactMethod"][value="${quote.contactInfo.method}"]`
                    );
                    if (contactMethodRadio) {
                        contactMethodRadio.checked = true;
                    }
                }

                // Load items
                if (quote.items && quote.items.length > 0) {
                    loadQuoteItems(quote.items, quote.name);
                } else {
                    // If no items, add one default item and go to items page for editing
                    addNewItem();
                    setTimeout(() => {
                        nextStep(2);
                        showSuccessNotification(
                            `Quote "${quote.name}" loaded successfully! You can now edit the items.`
                        );
                        // Clear loading flag
                        window.isLoadingQuote = false;
                    }, 500);
                }
            }

            // FIXED: Function to load quote items with improved timing and error handling
            function loadQuoteItems(savedItems, quoteName) {
                if (!savedItems || savedItems.length === 0) {
                    console.warn("No items to load for quote:", quoteName);
                    setTimeout(() => {
                        nextStep(2);
                        showSuccessNotification(
                            `Quote "${quoteName}" loaded but has no items. You can add items now.`
                        );
                        window.isLoadingQuote = false;
                    }, 500);
                    return;
                }

                console.log(
                    `Loading ${savedItems.length} items for quote: ${quoteName}`
                );

                let itemsLoaded = 0;
                let itemsWithErrors = 0;
                const totalItems = savedItems.length;

                // Show loading notification
                showSuccessNotification(`Loading ${totalItems} items...`);

                savedItems.forEach((savedItem, index) => {
                    console.log(
                        `Loading item ${index + 1} of ${totalItems}:`,
                        savedItem
                    );

                    try {
                        addNewItem();
                        const currentItem = items[items.length - 1];
                        const itemElement = document.getElementById(
                            currentItem.id
                        );

                        if (!itemElement) {
                            console.error(
                                "Item element not found:",
                                currentItem.id
                            );
                            itemsWithErrors++;
                            itemsLoaded++;
                            checkAllItemsLoaded();
                            return;
                        }

                        // FIXED: Set item type first with better error handling
                        const typeSelect =
                            itemElement.querySelector(".item-type");
                        if (typeSelect && savedItem.type) {
                            typeSelect.value = savedItem.type;

                            // Wait a bit for the type change to take effect
                            setTimeout(() => {
                                updateItemType(currentItem.id, savedItem.type);

                                // FIXED: Load item data based on type with better error handling
                                if (savedItem.type === "curtain_wall") {
                                    loadCurtainWallItem(
                                        currentItem,
                                        savedItem,
                                        (success = true) => {
                                            if (!success) itemsWithErrors++;
                                            itemsLoaded++;
                                            checkAllItemsLoaded();
                                        }
                                    );
                                } else {
                                    loadNormalItem(
                                        currentItem,
                                        savedItem,
                                        (success = true) => {
                                            if (!success) itemsWithErrors++;
                                            itemsLoaded++;
                                            checkAllItemsLoaded();
                                        }
                                    );
                                }
                            }, 200); // Small delay to ensure type change is processed
                        } else {
                            console.error(
                                `Invalid item type or type selector not found for item ${
                                    index + 1
                                }:`,
                                savedItem.type
                            );
                            itemsWithErrors++;
                            itemsLoaded++;
                            checkAllItemsLoaded();
                        }
                    } catch (error) {
                        console.error(
                            `Error loading item ${index + 1}:`,
                            error
                        );
                        itemsWithErrors++;
                        itemsLoaded++;
                        checkAllItemsLoaded();
                    }
                });

                function checkAllItemsLoaded() {
                    console.log(
                        `Items loaded: ${itemsLoaded}/${totalItems}, Errors: ${itemsWithErrors}`
                    );

                    if (itemsLoaded >= totalItems) {
                        // All items processed, navigate to items page for editing
                        setTimeout(() => {
                            nextStep(2);

                            // Show appropriate success message
                            if (itemsWithErrors === 0) {
                                showSuccessNotification(
                                    `Quote "${quoteName}" loaded successfully! All ${totalItems} items are ready for editing.`
                                );
                            } else if (itemsWithErrors < totalItems) {
                                showSuccessNotification(
                                    `Quote "${quoteName}" loaded with ${itemsWithErrors} errors. ${
                                        totalItems - itemsWithErrors
                                    } items loaded successfully.`
                                );
                            } else {
                                showSuccessNotification(
                                    `Quote "${quoteName}" loaded but all items had errors. Please check the console for details.`
                                );
                            }

                            // Clear loading flag
                            window.isLoadingQuote = false;

                            console.log(
                                `Quote loading completed for "${quoteName}". Items: ${totalItems}, Errors: ${itemsWithErrors}`
                            );
                        }, 800); // Increased delay to ensure all async operations complete
                    }
                }
            }

            // FIXED: Function to load curtain wall item data with improved profile selection
            function loadCurtainWallItem(currentItem, savedItem, callback) {
                console.log(
                    `Loading curtain wall item ${currentItem.id}:`,
                    savedItem
                );

                // FIXED: Load curtain wall data with enriched profile
                const enrichedProfile = savedItem.profile
                    ? enrichProfileData(savedItem.profile)
                    : null;

                currentItem.curtain = {
                    quantity: savedItem.quantity || 1,
                    glassType: savedItem.glassType || "double",
                    profile: enrichedProfile, // Use enriched profile data
                    designData: savedItem.designData,
                    visualSvg: savedItem.visualSvg,
                    wallWidth: savedItem.designData?.wallWidth || 0,
                    wallHeight: savedItem.designData?.wallHeight || 0,
                    frameMeters: savedItem.designData?.frameMeters || 0,
                    windowMeters: savedItem.designData?.windowMeters || 0,
                    glassArea: savedItem.designData?.glassArea || 0,
                    cornerCount: savedItem.designData?.cornerCount || 0,
                    panels: savedItem.designData?.panels || [],
                };

                // Wait for curtain wall UI to load
                setTimeout(() => {
                    try {
                        const itemElement = document.getElementById(
                            currentItem.id
                        );
                        if (!itemElement) {
                            console.error(
                                `Curtain wall item element not found: ${currentItem.id}`
                            );
                            callback();
                            return;
                        }

                        // Set glass type
                        const glassTypeRadio = itemElement.querySelector(
                            `input[name="curtainGlassType-${
                                currentItem.id
                            }"][value="${savedItem.glassType || "double"}"]`
                        );
                        if (glassTypeRadio) {
                            glassTypeRadio.checked = true;
                        }

                        // Set quantity
                        const quantityInput =
                            itemElement.querySelector(".curtain-quantity");
                        if (quantityInput) {
                            quantityInput.value = savedItem.quantity || 1;
                        }

                        // FIXED: If we have design data, show the summary with better error handling
                        if (savedItem.designData) {
                            const curtainDesigner = itemElement.querySelector(
                                `#curtainWallDesigner-${currentItem.id}`
                            );
                            const curtainSummary = itemElement.querySelector(
                                `#curtainWallSummary-${currentItem.id}`
                            );

                            if (curtainDesigner && curtainSummary) {
                                curtainDesigner.style.display = "none";
                                curtainSummary.style.display = "block";

                                // Add hidden input with design data
                                let hiddenInput = curtainSummary.querySelector(
                                    'input[name="curtainWallData"]'
                                );
                                if (!hiddenInput) {
                                    hiddenInput =
                                        document.createElement("input");
                                    hiddenInput.type = "hidden";
                                    hiddenInput.name = "curtainWallData";
                                    curtainSummary.appendChild(hiddenInput);
                                }
                                hiddenInput.value = JSON.stringify(
                                    savedItem.designData
                                );

                                // Show visual if available
                                if (savedItem.visualSvg) {
                                    const shapeEl =
                                        curtainSummary.querySelector(
                                            `#curtainWallShape-${currentItem.id}`
                                        );
                                    if (shapeEl) {
                                        shapeEl.innerHTML = savedItem.visualSvg;
                                    } else {
                                        console.warn(
                                            `Shape element not found for curtain wall item ${currentItem.id}`
                                        );
                                    }
                                }

                                console.log(
                                    `Curtain wall design data loaded for item ${currentItem.id}:`,
                                    savedItem.designData
                                );
                            } else {
                                console.warn(
                                    `Curtain wall designer/summary elements not found for item ${currentItem.id}`
                                );
                            }
                        } else {
                            console.warn(
                                `No design data found for curtain wall item ${currentItem.id}`
                            );
                        }

                        // FIXED: Load curtain wall profiles with improved selection logic
                        if (savedItem.profile) {
                            console.log(
                                `Loading curtain wall profiles for item ${currentItem.id}`
                            );
                            loadCurtainProfiles(currentItem.id);

                            // FIXED: Select the profile with improved matching and retry logic
                            const selectCurtainProfile = () => {
                                const profileGrid = document.getElementById(
                                    `curtain-profile-grid-${currentItem.id}`
                                );
                                const profileCards = profileGrid
                                    ? profileGrid.querySelectorAll(
                                          ".profile-card"
                                      )
                                    : [];

                                if (profileCards.length > 0) {
                                    console.log(
                                        `Attempting to select curtain wall profile for item ${currentItem.id}:`,
                                        savedItem.profile
                                    );

                                    let profileFound = false;
                                    const savedProfileCode =
                                        savedItem.profile.code ||
                                        savedItem.profile.profile_code ||
                                        "";
                                    const savedProfileName =
                                        savedItem.profile.name ||
                                        savedItem.profile.profile_name ||
                                        "";

                                    profileCards.forEach((card) => {
                                        const profileCodeEl =
                                            card.querySelector(".profile-code");
                                        const profileNameEl =
                                            card.querySelector(".profile-name");

                                        if (profileCodeEl && profileNameEl) {
                                            const cardCode =
                                                profileCodeEl.textContent.trim();
                                            const cardName =
                                                profileNameEl.textContent.trim();

                                            // Try multiple matching strategies
                                            const codeMatch =
                                                cardCode === savedProfileCode ||
                                                cardCode.toLowerCase() ===
                                                    savedProfileCode.toLowerCase();
                                            const nameMatch =
                                                cardName === savedProfileName ||
                                                cardName.toLowerCase() ===
                                                    savedProfileName.toLowerCase();

                                            if (
                                                codeMatch ||
                                                (nameMatch && savedProfileName)
                                            ) {
                                                // Clear any existing selections first
                                                profileCards.forEach((c) => {
                                                    c.classList.remove(
                                                        "selected"
                                                    );
                                                    const existingBadge =
                                                        c.querySelector(
                                                            ".profile-selected-badge"
                                                        );
                                                    if (existingBadge)
                                                        existingBadge.remove();
                                                });

                                                // Select this card
                                                card.classList.add("selected");

                                                // Add selected badge
                                                const badge =
                                                    document.createElement(
                                                        "div"
                                                    );
                                                badge.className =
                                                    "profile-selected-badge";
                                                badge.innerHTML =
                                                    '<i class="fas fa-check"></i> Selected';
                                                card.appendChild(badge);

                                                // Update the item's profile with the full profile data
                                                const fullProfile =
                                                    profiles.find(
                                                        (p) =>
                                                            String(
                                                                p.profile_code ||
                                                                    ""
                                                            ).trim() ===
                                                                cardCode ||
                                                            String(
                                                                p.profile_name ||
                                                                    ""
                                                            ).trim() ===
                                                                cardName
                                                    );

                                                if (fullProfile) {
                                                    currentItem.curtain.profile =
                                                        enrichProfileData(
                                                            fullProfile
                                                        );
                                                    console.log(
                                                        `Curtain wall profile selected and updated for item ${currentItem.id}:`,
                                                        currentItem.curtain
                                                            .profile
                                                    );
                                                }

                                                profileFound = true;
                                                return; // Exit forEach early
                                            }
                                        }
                                    });

                                    if (!profileFound) {
                                        console.warn(
                                            `Curtain wall profile not found for item ${currentItem.id}. Looking for:`,
                                            {
                                                code: savedProfileCode,
                                                name: savedProfileName,
                                                availableProfiles: Array.from(
                                                    profileCards
                                                ).map((card) => ({
                                                    code: card
                                                        .querySelector(
                                                            ".profile-code"
                                                        )
                                                        ?.textContent?.trim(),
                                                    name: card
                                                        .querySelector(
                                                            ".profile-name"
                                                        )
                                                        ?.textContent?.trim(),
                                                })),
                                            }
                                        );
                                    }
                                } else {
                                    console.log(
                                        `No curtain wall profile cards found yet for item ${currentItem.id}, retrying...`
                                    );
                                    // Retry after a short delay
                                    setTimeout(selectCurtainProfile, 500);
                                    return;
                                }
                            };

                            // Wait for profiles to load, then select
                            setTimeout(selectCurtainProfile, 1800);
                        }

                        callback();
                    } catch (error) {
                        console.error(
                            "Error loading curtain wall item:",
                            error
                        );
                        callback();
                    }
                }, 800);
            }

            // FIXED: Function to load normal item data with improved profile selection
            function loadNormalItem(currentItem, savedItem, callback) {
                setTimeout(() => {
                    try {
                        const itemElement = document.getElementById(
                            currentItem.id
                        );
                        if (!itemElement) {
                            console.error(
                                `Item element not found: ${currentItem.id}`
                            );
                            callback();
                            return;
                        }

                        console.log(
                            `Loading normal item ${currentItem.id}:`,
                            savedItem
                        );

                        // Load form field values
                        const fieldMappings = {
                            ".item-width": savedItem.width || "",
                            ".item-height": savedItem.height || "",
                            ".item-quantity": savedItem.quantity || 1,
                            ".item-system": savedItem.system || "",
                            ".item-leaves": savedItem.leaves || 2,
                            ".item-color": savedItem.color || "",
                            ".item-glass-appearance":
                                savedItem.glassAppearance || "clear",
                            ".item-upper-panel-type":
                                savedItem.upperPanelType || "hinged",
                        };

                        Object.entries(fieldMappings).forEach(
                            ([selector, value]) => {
                                const field =
                                    itemElement.querySelector(selector);
                                if (field) {
                                    field.value = value;
                                } else {
                                    console.warn(
                                        `Field not found: ${selector} for item ${currentItem.id}`
                                    );
                                }
                            }
                        );

                        // Set glass type radio button
                        const glassTypeRadio = itemElement.querySelector(
                            `input[name="glassType-${currentItem.id}"][value="${
                                savedItem.glassType || "double"
                            }"]`
                        );
                        if (glassTypeRadio) {
                            glassTypeRadio.checked = true;
                        }

                        // Set checkboxes
                        const checkboxMappings = {
                            ".item-argon": savedItem.argon || false,
                            ".item-mosquito": savedItem.mosquito || false,
                            ".item-arch": savedItem.arch || false,
                        };

                        Object.entries(checkboxMappings).forEach(
                            ([selector, checked]) => {
                                const checkbox =
                                    itemElement.querySelector(selector);
                                if (checkbox) checkbox.checked = checked;
                            }
                        );

                        // Set net type if applicable
                        if (savedItem.netType) {
                            const netTypeSelect =
                                itemElement.querySelector(".item-net-type");
                            if (netTypeSelect) {
                                netTypeSelect.value = savedItem.netType;
                            }
                        }

                        // FIXED: Update item object with enriched profile data
                        const enrichedProfile = savedItem.profile
                            ? enrichProfileData(savedItem.profile)
                            : null;

                        Object.assign(currentItem, {
                            type: savedItem.type,
                            width: savedItem.width || 0,
                            height: savedItem.height || 0,
                            quantity: savedItem.quantity || 1,
                            leaves: savedItem.leaves || 2,
                            system: savedItem.system || "",
                            profile: enrichedProfile, // Use enriched profile data
                            color: savedItem.color || "",
                            glassType: savedItem.glassType || "double",
                            glassAppearance:
                                savedItem.glassAppearance || "clear",
                            argon: savedItem.argon || false,
                            mosquito: savedItem.mosquito || false,
                            arch: savedItem.arch || false,
                            netType: savedItem.netType || null,
                            upperPanelType:
                                savedItem.upperPanelType || "hinged",
                        });

                        // Update leaves dropdown and field visibility first
                        updateLeavesDropdown(
                            currentItem.id,
                            savedItem.system || ""
                        );
                        toggleNetTypeField(currentItem.id);
                        toggleUpperPanelTypeField(currentItem.id);

                        // FIXED: Trigger profile options update with better timing and error handling
                        if (
                            savedItem.width &&
                            savedItem.height &&
                            savedItem.system
                        ) {
                            console.log(
                                `Updating profile options for item ${currentItem.id}`
                            );
                            updateProfileOptions(currentItem.id);

                            // FIXED: Select the saved profile with improved matching and retry logic
                            if (savedItem.profile) {
                                const selectSavedProfile = () => {
                                    const profileGrid = document.getElementById(
                                        `profile-grid-${currentItem.id}`
                                    );
                                    const profileCards = profileGrid
                                        ? profileGrid.querySelectorAll(
                                              ".profile-card"
                                          )
                                        : [];

                                    if (profileCards.length > 0) {
                                        console.log(
                                            `Attempting to select profile for item ${currentItem.id}:`,
                                            savedItem.profile
                                        );

                                        let profileFound = false;
                                        const savedProfileCode =
                                            savedItem.profile.code ||
                                            savedItem.profile.profile_code ||
                                            "";
                                        const savedProfileName =
                                            savedItem.profile.name ||
                                            savedItem.profile.profile_name ||
                                            "";

                                        profileCards.forEach((card) => {
                                            const profileCodeEl =
                                                card.querySelector(
                                                    ".profile-code"
                                                );
                                            const profileNameEl =
                                                card.querySelector(
                                                    ".profile-name"
                                                );

                                            if (
                                                profileCodeEl &&
                                                profileNameEl
                                            ) {
                                                const cardCode =
                                                    profileCodeEl.textContent.trim();
                                                const cardName =
                                                    profileNameEl.textContent.trim();

                                                // Try multiple matching strategies
                                                const codeMatch =
                                                    cardCode ===
                                                        savedProfileCode ||
                                                    cardCode.toLowerCase() ===
                                                        savedProfileCode.toLowerCase();
                                                const nameMatch =
                                                    cardName ===
                                                        savedProfileName ||
                                                    cardName.toLowerCase() ===
                                                        savedProfileName.toLowerCase();

                                                if (
                                                    codeMatch ||
                                                    (nameMatch &&
                                                        savedProfileName)
                                                ) {
                                                    // Clear any existing selections first
                                                    profileCards.forEach(
                                                        (c) => {
                                                            c.classList.remove(
                                                                "selected"
                                                            );
                                                            const existingBadge =
                                                                c.querySelector(
                                                                    ".profile-selected-badge"
                                                                );
                                                            if (existingBadge)
                                                                existingBadge.remove();
                                                        }
                                                    );

                                                    // Select this card
                                                    card.classList.add(
                                                        "selected"
                                                    );

                                                    // Add selected badge
                                                    const badge =
                                                        document.createElement(
                                                            "div"
                                                        );
                                                    badge.className =
                                                        "profile-selected-badge";
                                                    badge.innerHTML =
                                                        '<i class="fas fa-check"></i> Selected';
                                                    card.appendChild(badge);

                                                    // Update the item's profile with the full profile data
                                                    const fullProfile =
                                                        profiles.find(
                                                            (p) =>
                                                                String(
                                                                    p.profile_code ||
                                                                        ""
                                                                ).trim() ===
                                                                    cardCode ||
                                                                String(
                                                                    p.profile_name ||
                                                                        ""
                                                                ).trim() ===
                                                                    cardName
                                                        );

                                                    if (fullProfile) {
                                                        currentItem.profile =
                                                            enrichProfileData(
                                                                fullProfile
                                                            );
                                                        console.log(
                                                            `Profile selected and updated for item ${currentItem.id}:`,
                                                            currentItem.profile
                                                        );
                                                    }

                                                    profileFound = true;
                                                    return; // Exit forEach early
                                                }
                                            }
                                        });

                                        if (!profileFound) {
                                            console.warn(
                                                `Profile not found for item ${currentItem.id}. Looking for:`,
                                                {
                                                    code: savedProfileCode,
                                                    name: savedProfileName,
                                                    availableProfiles:
                                                        Array.from(
                                                            profileCards
                                                        ).map((card) => ({
                                                            code: card
                                                                .querySelector(
                                                                    ".profile-code"
                                                                )
                                                                ?.textContent?.trim(),
                                                            name: card
                                                                .querySelector(
                                                                    ".profile-name"
                                                                )
                                                                ?.textContent?.trim(),
                                                        })),
                                                }
                                            );
                                        }
                                    } else {
                                        console.log(
                                            `No profile cards found yet for item ${currentItem.id}, retrying...`
                                        );
                                        // Retry after a short delay
                                        setTimeout(selectSavedProfile, 500);
                                        return;
                                    }
                                };

                                // Wait for profiles to load, then select
                                setTimeout(selectSavedProfile, 1200);
                            }
                        } else {
                            console.warn(
                                `Missing required data for profile loading:`,
                                {
                                    width: savedItem.width,
                                    height: savedItem.height,
                                    system: savedItem.system,
                                }
                            );
                        }

                        // Generate SVG for normal items when loaded
                        if (currentItem.width && currentItem.height) {
                            currentItem.visualSvg =
                                generateNormalItemSvg(currentItem);

                            // Update the summary display
                            updateNormalItemSummary(currentItem.id);
                        }

                        callback();
                    } catch (error) {
                        console.error("Error loading normal item:", error);
                        callback();
                    }
                }, 300);
            }

            // Embedded Curtain Wall Designer State Management
            const curtainDesignerStates = new Map();

            // Initialize curtain wall designer for a specific item
            function initCurtainWallDesigner(itemId) {
                const state = {
                    cols: 4,
                    rows: 3,
                    wallWidth: 4.0,
                    wallHeight: 3.0,
                    columnSizes: [1.0, 1.0, 1.0, 1.0], // Width of each column
                    rowSizes: [1.0, 1.0, 1.0], // Height of each row
                    currentMode: "structure",
                    panels: [],
                    selectedPanels: new Set(),
                    mergedPanels: new Map(),
                    nextPanelId: 1,
                };

                curtainDesignerStates.set(itemId, state);

                // Initialize the grid
                initCurtainGrid(itemId);

                // Set up event listeners
                setupCurtainEventListeners(itemId);

                // Update size inputs
                updateSizeInputs(itemId);
            }

            // Initialize curtain wall grid
            function initCurtainGrid(itemId) {
                const state = curtainDesignerStates.get(itemId);
                if (!state) return;

                const panelColsInput = document.getElementById(
                    `curtain-panel-cols-${itemId}`
                );
                const panelRowsInput = document.getElementById(
                    `curtain-panel-rows-${itemId}`
                );
                const wallWidthInput = document.getElementById(
                    `curtain-wall-width-${itemId}`
                );
                const wallHeightInput = document.getElementById(
                    `curtain-wall-height-${itemId}`
                );
                const panelGrid = document.getElementById(
                    `curtain-panel-grid-${itemId}`
                );

                if (!panelGrid) return;

                state.cols = parseInt(panelColsInput?.value) || 4;
                state.rows = parseInt(panelRowsInput?.value) || 3;
                state.wallWidth = parseFloat(wallWidthInput?.value) || 4.0;
                state.wallHeight = parseFloat(wallHeightInput?.value) || 3.0;

                // Calculate total dimensions for positioning
                const totalColumnSize = state.columnSizes
                    .slice(0, state.cols)
                    .reduce((sum, size) => sum + size, 0);
                const totalRowSize = state.rowSizes
                    .slice(0, state.rows)
                    .reduce((sum, size) => sum + size, 0);

                // Set container dimensions
                const containerWidth =
                    (state.wallWidth / totalColumnSize) * 100;
                const containerHeight = (state.wallHeight / totalRowSize) * 100;
                panelGrid.style.width = `${containerWidth}%`;
                panelGrid.style.height = `${containerHeight}%`;

                console.log(
                    "Column sizes:",
                    state.columnSizes.slice(0, state.cols)
                );
                console.log("Row sizes:", state.rowSizes.slice(0, state.rows));
                console.log(
                    "Container dimensions:",
                    containerWidth + "% x " + containerHeight + "%"
                );

                // Clear existing grid
                panelGrid.innerHTML = "";
                state.panels = [];
                state.selectedPanels.clear();
                state.mergedPanels.clear();
                state.nextPanelId = 1;

                // Calculate cumulative positions for each panel
                let cumulativeColWidth = 0;
                let cumulativeRowHeight = 0;

                // Create panels with calculated positions based on neighbors
                for (let row = 0; row < state.rows; row++) {
                    cumulativeColWidth = 0; // Reset for each row

                    for (let col = 0; col < state.cols; col++) {
                        const panelId = state.nextPanelId++;

                        // Calculate panel dimensions in meters
                        const panelWidthMeters =
                            (state.columnSizes[col] / totalColumnSize) *
                            state.wallWidth;
                        const panelHeightMeters =
                            (state.rowSizes[row] / totalRowSize) *
                            state.wallHeight;

                        // Calculate position as percentages
                        const panelWidthPercent =
                            (state.columnSizes[col] / totalColumnSize) * 100;
                        const panelHeightPercent =
                            (state.rowSizes[row] / totalRowSize) * 100;

                        // Calculate position based on previous panels
                        const left = cumulativeColWidth;
                        const top = cumulativeRowHeight;

                        const panel = {
                            id: panelId,
                            row,
                            col,
                            width: panelWidthPercent,
                            height: panelHeightPercent,
                            widthMeters: panelWidthMeters,
                            heightMeters: panelHeightMeters,
                            left: left,
                            top: top,
                            type: null,
                            merged: false,
                            mergedId: null,
                        };

                        state.panels.push(panel);

                        const panelEl = createCurtainPanelElement(
                            itemId,
                            panel
                        );
                        panelGrid.appendChild(panelEl);

                        // Update cumulative width for next column
                        cumulativeColWidth += panelWidthPercent;
                    }

                    // Update cumulative height for next row (use the current row's height)
                    cumulativeRowHeight +=
                        (state.rowSizes[row] / totalRowSize) * 100;
                }

                // Update info
                const selectedPanelInfo = document.getElementById(
                    `curtain-selected-panel-info-${itemId}`
                );
                if (selectedPanelInfo) {
                    selectedPanelInfo.innerHTML = `<p>Grid: ${state.cols} columns  ${state.rows} rows</p>`;
                }

                updateCurtainResults(itemId);
            }

            // Update size inputs for columns and rows
            function updateSizeInputs(itemId) {
                const state = curtainDesignerStates.get(itemId);
                if (!state) return;

                const columnSizesContainer = document.getElementById(
                    `curtain-column-sizes-${itemId}`
                );
                const rowSizesContainer = document.getElementById(
                    `curtain-row-sizes-${itemId}`
                );

                if (!columnSizesContainer || !rowSizesContainer) return;

                // Update column sizes
                columnSizesContainer.innerHTML = "";
                for (let i = 0; i < state.cols; i++) {
                    const input = document.createElement("input");
                    input.type = "number";
                    input.min = "0.1";
                    input.step = "0.1";
                    input.value = state.columnSizes[i] || 1;
                    input.placeholder = `C${i + 1}`;
                    input.addEventListener("change", (e) => {
                        const value = parseFloat(e.target.value) || 1;
                        state.columnSizes[i] = value;
                        // Ensure we have enough sizes
                        while (state.columnSizes.length < state.cols) {
                            state.columnSizes.push(1);
                        }
                        initCurtainGrid(itemId);
                        updateCurtainResults(itemId);
                    });
                    columnSizesContainer.appendChild(input);
                }

                // Update row sizes
                rowSizesContainer.innerHTML = "";
                for (let i = 0; i < state.rows; i++) {
                    const input = document.createElement("input");
                    input.type = "number";
                    input.min = "0.1";
                    input.step = "0.1";
                    input.value = state.rowSizes[i] || 1;
                    input.placeholder = `R${i + 1}`;
                    input.addEventListener("change", (e) => {
                        const value = parseFloat(e.target.value) || 1;
                        state.rowSizes[i] = value;
                        // Ensure we have enough sizes
                        while (state.rowSizes.length < state.rows) {
                            state.rowSizes.push(1);
                        }
                        initCurtainGrid(itemId);
                        updateCurtainResults(itemId);
                    });
                    rowSizesContainer.appendChild(input);
                }
            }

            // Create curtain panel DOM element
            function createCurtainPanelElement(itemId, panel) {
                const state = curtainDesignerStates.get(itemId);
                if (!state) return document.createElement("div");

                const panelEl = document.createElement("div");
                panelEl.className = "curtain-panel";
                panelEl.dataset.id = panel.id;
                panelEl.dataset.itemId = itemId;

                // Set panel position and size based on calculated values
                panelEl.style.left = `${panel.left}%`;
                panelEl.style.top = `${panel.top}%`;
                panelEl.style.width = `${panel.width}%`;
                panelEl.style.height = `${panel.height}%`;

                // Add content
                const idSpan = document.createElement("span");
                idSpan.className = "panel-id";
                idSpan.textContent = `ID: ${panel.id}`;
                panelEl.appendChild(idSpan);

                const sizeSpan = document.createElement("span");
                sizeSpan.className = "panel-size";
                // Use the pre-calculated meter dimensions
                sizeSpan.textContent = `${panel.widthMeters.toFixed(
                    1
                )}m  ${panel.heightMeters.toFixed(1)}m`;
                panelEl.appendChild(sizeSpan);

                const typeSpan = document.createElement("span");
                typeSpan.className = "panel-type";
                typeSpan.textContent = panel.type
                    ? panel.type.charAt(0).toUpperCase() + panel.type.slice(1)
                    : "Empty";
                panelEl.appendChild(typeSpan);

                // Add click handler
                panelEl.addEventListener("click", (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        // Add to selection
                        toggleCurtainPanelSelection(itemId, panel.id);
                    } else {
                        // Single selection
                        state.selectedPanels.clear();
                        state.selectedPanels.add(panel.id);
                        updateCurtainPanelSelection(itemId);

                        // Apply current mode if not merging
                        if (state.currentMode) {
                            setCurtainPanelType(
                                itemId,
                                panel.id,
                                state.currentMode
                            );
                        }
                    }

                    // Recalculate
                    calculateCurtainResults(itemId);
                });

                return panelEl;
            }

            // Set up event listeners for curtain wall designer
            function setupCurtainEventListeners(itemId) {
                // Mode buttons
                const modeSelector = document.getElementById(
                    `curtain-mode-selector-${itemId}`
                );
                if (modeSelector) {
                    const modeButtons =
                        modeSelector.querySelectorAll(".curtain-mode-btn");
                    modeButtons.forEach((btn) => {
                        btn.addEventListener("click", () =>
                            setCurtainMode(itemId, btn.dataset.mode)
                        );
                    });
                }

                // Control buttons
                const clearSelectionBtn = document.getElementById(
                    `curtain-clear-selection-${itemId}`
                );
                if (clearSelectionBtn) {
                    clearSelectionBtn.addEventListener("click", () => {
                        const state = curtainDesignerStates.get(itemId);
                        if (state) {
                            state.selectedPanels.clear();
                            updateCurtainPanelSelection(itemId);
                        }
                    });
                }

                const mergeBtn = document.getElementById(
                    `curtain-merge-btn-${itemId}`
                );
                if (mergeBtn) {
                    mergeBtn.addEventListener("click", () =>
                        mergeCurtainPanels(itemId)
                    );
                }

                const splitBtn = document.getElementById(
                    `curtain-split-btn-${itemId}`
                );
                if (splitBtn) {
                    splitBtn.addEventListener("click", () =>
                        splitCurtainPanel(itemId)
                    );
                }

                const applyGridBtn = document.getElementById(
                    `curtain-apply-grid-${itemId}`
                );
                if (applyGridBtn) {
                    applyGridBtn.addEventListener("click", () =>
                        initCurtainGrid(itemId)
                    );
                }

                const saveDesignBtn = document.getElementById(
                    `curtain-save-design-${itemId}`
                );
                if (saveDesignBtn) {
                    saveDesignBtn.addEventListener("click", () =>
                        saveCurtainDesign(itemId)
                    );
                }

                // Dimension inputs
                const wallWidthInput = document.getElementById(
                    `curtain-wall-width-${itemId}`
                );
                const wallHeightInput = document.getElementById(
                    `curtain-wall-height-${itemId}`
                );

                if (wallWidthInput) {
                    wallWidthInput.addEventListener("change", () => {
                        const state = curtainDesignerStates.get(itemId);
                        if (state) {
                            state.wallWidth =
                                parseFloat(wallWidthInput.value) || 4.0;
                            initCurtainGrid(itemId);
                        }
                    });
                }

                if (wallHeightInput) {
                    wallHeightInput.addEventListener("change", () => {
                        const state = curtainDesignerStates.get(itemId);
                        if (state) {
                            state.wallHeight =
                                parseFloat(wallHeightInput.value) || 3.0;
                            initCurtainGrid(itemId);
                        }
                    });
                }

                // Grid size inputs
                const panelColsInput = document.getElementById(
                    `curtain-panel-cols-${itemId}`
                );
                const panelRowsInput = document.getElementById(
                    `curtain-panel-rows-${itemId}`
                );

                if (panelColsInput) {
                    panelColsInput.addEventListener("change", () => {
                        const state = curtainDesignerStates.get(itemId);
                        if (state) {
                            const newCols = parseInt(panelColsInput.value) || 4;
                            state.cols = newCols;

                            // Adjust column sizes array
                            while (state.columnSizes.length < newCols) {
                                state.columnSizes.push(1);
                            }
                            state.columnSizes = state.columnSizes.slice(
                                0,
                                newCols
                            );

                            initCurtainGrid(itemId);
                            updateSizeInputs(itemId);
                        }
                    });
                }

                if (panelRowsInput) {
                    panelRowsInput.addEventListener("change", () => {
                        const state = curtainDesignerStates.get(itemId);
                        if (state) {
                            const newRows = parseInt(panelRowsInput.value) || 3;
                            state.rows = newRows;

                            // Adjust row sizes array
                            while (state.rowSizes.length < newRows) {
                                state.rowSizes.push(1);
                            }
                            state.rowSizes = state.rowSizes.slice(0, newRows);

                            initCurtainGrid(itemId);
                            updateSizeInputs(itemId);
                        }
                    });
                }
            }

            // Set curtain wall mode
            function setCurtainMode(itemId, mode) {
                const state = curtainDesignerStates.get(itemId);
                if (!state) return;

                state.currentMode = mode;

                // Update UI
                const modeSelector = document.getElementById(
                    `curtain-mode-selector-${itemId}`
                );
                if (modeSelector) {
                    const modeButtons =
                        modeSelector.querySelectorAll(".curtain-mode-btn");
                    modeButtons.forEach((btn) => {
                        if (btn.dataset.mode === mode) {
                            btn.classList.add("active");
                        } else {
                            btn.classList.remove("active");
                        }
                    });
                }

                // Apply to selected panels
                if (state.selectedPanels.size > 0 && mode) {
                    state.selectedPanels.forEach((panelId) => {
                        setCurtainPanelType(itemId, panelId, mode);
                    });
                }
            }

            // Toggle curtain panel selection
            function toggleCurtainPanelSelection(itemId, panelId) {
                const state = curtainDesignerStates.get(itemId);
                if (!state) return;

                if (state.selectedPanels.has(panelId)) {
                    state.selectedPanels.delete(panelId);
                } else {
                    state.selectedPanels.add(panelId);
                }
                updateCurtainPanelSelection(itemId);
            }

            // Update curtain panel selection UI
            function updateCurtainPanelSelection(itemId) {
                const state = curtainDesignerStates.get(itemId);
                if (!state) return;

                // Update UI for all panels
                state.panels.forEach((panel) => {
                    updateCurtainPanelElement(itemId, panel.id);
                });

                // Update info panel
                const selectedPanelInfo = document.getElementById(
                    `curtain-selected-panel-info-${itemId}`
                );
                if (!selectedPanelInfo) return;

                if (state.selectedPanels.size === 0) {
                    selectedPanelInfo.innerHTML = `<p>No panel selected</p>`;
                } else if (state.selectedPanels.size === 1) {
                    const panelId = Array.from(state.selectedPanels)[0];
                    const panel = state.panels.find((p) => p.id === panelId);

                    let summaryHTML = `
                    <p>Selected Panel: #${panel.id}</p>
                    <p>Type: ${panel.type || "Not set"}</p>
                    <p>Size: ${panel.width.toFixed(
                        2
                    )}m  ${panel.height.toFixed(2)}m</p>
                    <p>Position: Row ${panel.row + 1}, Col ${panel.col + 1}</p>
                `;

                    if (panel.merged) {
                        summaryHTML += `<div class="curtain-panel-summary">
                        <div class="curtain-panel-summary-item"><span>Merged Panel</span></div>
                        <div class="curtain-panel-summary-item"><span>Contains:</span> <span>${
                            panel.mergedPanels?.length || 0
                        } panels</span></div>
                    </div>`;
                    }

                    selectedPanelInfo.innerHTML = summaryHTML;
                } else {
                    selectedPanelInfo.innerHTML = `
                    <p>${state.selectedPanels.size} panels selected</p>
                    <p>Click "Merge Panels" to combine them</p>
                `;
                }
            }

            // Update curtain panel element appearance
            function updateCurtainPanelElement(itemId, panelId) {
                const state = curtainDesignerStates.get(itemId);
                if (!state) return;

                const panel = state.panels.find((p) => p.id === panelId);
                if (!panel) return;

                const panelEl = document.querySelector(
                    `.curtain-panel[data-id="${panelId}"][data-item-id="${itemId}"]`
                );
                if (!panelEl) return;

                // Reset classes
                panelEl.className = "curtain-panel";
                if (panel.merged) panelEl.classList.add("merged");

                // Add type class
                if (panel.type) {
                    panelEl.classList.add(panel.type);
                }

                // Update selection
                if (state.selectedPanels.has(panelId)) {
                    panelEl.classList.add("selected");
                }

                // Update content
                const typeSpan = panelEl.querySelector(".panel-type");
                if (typeSpan) {
                    typeSpan.textContent = panel.type
                        ? panel.type.charAt(0).toUpperCase() +
                          panel.type.slice(1)
                        : "Empty";
                }

                const sizeSpan = panelEl.querySelector(".panel-size");
                if (sizeSpan) {
                    // Use the pre-calculated meter dimensions
                    sizeSpan.textContent = `${panel.widthMeters.toFixed(
                        1
                    )}m  ${panel.heightMeters.toFixed(1)}m`;
                }
            }

            // Set curtain panel type
            function setCurtainPanelType(itemId, panelId, type) {
                const state = curtainDesignerStates.get(itemId);
                if (!state) return;

                const panel = state.panels.find((p) => p.id === panelId);
                if (panel) {
                    panel.type = type;
                    updateCurtainPanelElement(itemId, panelId);
                    calculateCurtainResults(itemId);
                }
            }

            // Merge curtain panels
            function mergeCurtainPanels(itemId) {
                const state = curtainDesignerStates.get(itemId);
                if (!state || state.selectedPanels.size < 2) return;

                const panelIds = Array.from(state.selectedPanels);
                const panels = state.panels.filter((p) =>
                    panelIds.includes(p.id)
                );

                // Find min and max rows/cols
                let minRow = Infinity,
                    maxRow = -Infinity;
                let minCol = Infinity,
                    maxCol = -Infinity;

                panels.forEach((panel) => {
                    minRow = Math.min(minRow, panel.row);
                    maxRow = Math.max(maxRow, panel.row);
                    minCol = Math.min(minCol, panel.col);
                    maxCol = Math.max(maxCol, panel.col);
                });

                // Calculate new size (both percentage and meters)
                const widthPercent = (maxCol - minCol + 1) * panels[0].width;
                const heightPercent = (maxRow - minRow + 1) * panels[0].height;
                const widthMeters =
                    (maxCol - minCol + 1) * panels[0].widthMeters;
                const heightMeters =
                    (maxRow - minRow + 1) * panels[0].heightMeters;

                // Create merged panel
                const mergedPanelId = state.nextPanelId++;
                const mergedPanel = {
                    id: mergedPanelId,
                    row: minRow,
                    col: minCol,
                    width: widthPercent,
                    height: heightPercent,
                    widthMeters: widthMeters,
                    heightMeters: heightMeters,
                    type: null,
                    merged: true,
                    mergedPanels: panelIds,
                };

                // Mark original panels as merged
                panels.forEach((panel) => {
                    panel.merged = true;
                    panel.mergedId = mergedPanelId;
                });

                // Add to state
                state.panels.push(mergedPanel);
                state.mergedPanels.set(mergedPanelId, mergedPanel);

                // Create merged panel element using CSS Grid spanning
                const panelGrid = document.getElementById(
                    `curtain-panel-grid-${itemId}`
                );
                if (panelGrid) {
                    const mergedPanelEl = document.createElement("div");
                    mergedPanelEl.className = "curtain-panel merged";
                    mergedPanelEl.dataset.id = mergedPanelId;
                    mergedPanelEl.dataset.itemId = itemId;

                    // Use CSS Grid spanning for perfect positioning
                    mergedPanelEl.style.gridColumn = `${minCol + 1} / span ${
                        maxCol - minCol + 1
                    }`;
                    mergedPanelEl.style.gridRow = `${minRow + 1} / span ${
                        maxRow - minRow + 1
                    }`;

                    // Add content
                    const idSpan = document.createElement("span");
                    idSpan.className = "panel-id";
                    idSpan.textContent = `M: ${mergedPanelId}`;
                    mergedPanelEl.appendChild(idSpan);

                    const sizeSpan = document.createElement("span");
                    sizeSpan.className = "panel-size";
                    sizeSpan.textContent = `${widthMeters.toFixed(
                        1
                    )}m  ${heightMeters.toFixed(1)}m`;
                    mergedPanelEl.appendChild(sizeSpan);

                    const typeSpan = document.createElement("span");
                    typeSpan.className = "panel-type";
                    typeSpan.textContent = "Merged";
                    mergedPanelEl.appendChild(typeSpan);

                    // Add click handler
                    mergedPanelEl.addEventListener("click", (e) => {
                        state.selectedPanels.clear();
                        state.selectedPanels.add(mergedPanelId);
                        updateCurtainPanelSelection(itemId);

                        if (state.currentMode) {
                            setCurtainPanelType(
                                itemId,
                                mergedPanelId,
                                state.currentMode
                            );
                        }
                    });

                    panelGrid.appendChild(mergedPanelEl);
                }

                // Hide original panels
                panels.forEach((panel) => {
                    const panelEl = document.querySelector(
                        `.curtain-panel[data-id="${panel.id}"][data-item-id="${itemId}"]`
                    );
                    if (panelEl) {
                        panelEl.style.display = "none";
                    }
                });

                // Clear selection
                state.selectedPanels.clear();
                state.selectedPanels.add(mergedPanelId);
                updateCurtainPanelSelection(itemId);

                // Recalculate
                calculateCurtainResults(itemId);
            }

            // Split curtain panel
            function splitCurtainPanel(itemId) {
                const state = curtainDesignerStates.get(itemId);
                if (!state || state.selectedPanels.size !== 1) return;

                const panelId = Array.from(state.selectedPanels)[0];
                const mergedPanel = state.mergedPanels.get(panelId);

                if (!mergedPanel) return;

                // Remove merged panel from DOM
                const mergedPanelEl = document.querySelector(
                    `.curtain-panel[data-id="${panelId}"][data-item-id="${itemId}"]`
                );
                if (mergedPanelEl) mergedPanelEl.remove();

                // Remove from state
                state.mergedPanels.delete(panelId);
                state.panels = state.panels.filter((p) => p.id !== panelId);

                // Restore original panels
                if (mergedPanel.mergedPanels) {
                    mergedPanel.mergedPanels.forEach((id) => {
                        const panel = state.panels.find((p) => p.id === id);
                        if (panel) {
                            panel.merged = false;
                            panel.mergedId = null;

                            // Show the panel again
                            const panelEl = document.querySelector(
                                `.curtain-panel[data-id="${id}"][data-item-id="${itemId}"]`
                            );
                            if (panelEl) {
                                panelEl.style.display = "flex";
                                panelEl.style.gridColumn = "span 1";
                                panelEl.style.gridRow = "span 1";
                            }
                        }
                    });
                }

                // Clear selection
                state.selectedPanels.clear();
                updateCurtainPanelSelection(itemId);

                // Recalculate
                calculateCurtainResults(itemId);
            }

            // Update curtain results display
            function updateCurtainResults(itemId) {
                const frameMetersEl = document.getElementById(
                    `curtain-frame-meters-${itemId}`
                );
                const windowMetersEl = document.getElementById(
                    `curtain-window-meters-${itemId}`
                );
                const glassAreaEl = document.getElementById(
                    `curtain-glass-area-${itemId}`
                );
                const cornerCountEl = document.getElementById(
                    `curtain-corner-count-${itemId}`
                );
                const panelCountEl = document.getElementById(
                    `curtain-panel-count-${itemId}`
                );
                const windowCountEl = document.getElementById(
                    `curtain-window-count-${itemId}`
                );
                const doorCountEl = document.getElementById(
                    `curtain-door-count-${itemId}`
                );
                const sharedEdgesEl = document.getElementById(
                    `curtain-shared-edges-${itemId}`
                );
                const externalPerimeterEl = document.getElementById(
                    `curtain-external-perimeter-${itemId}`
                );
                const internalDividersEl = document.getElementById(
                    `curtain-internal-dividers-${itemId}`
                );
                const totalFrameDisplayEl = document.getElementById(
                    `curtain-total-frame-display-${itemId}`
                );

                if (frameMetersEl) frameMetersEl.textContent = "0.00";
                if (windowMetersEl) windowMetersEl.textContent = "0.00";
                if (glassAreaEl) glassAreaEl.textContent = "0.00 m";
                if (cornerCountEl) cornerCountEl.textContent = "0";
                if (panelCountEl) panelCountEl.textContent = "0";
                if (windowCountEl) windowCountEl.textContent = "0";
                if (doorCountEl) doorCountEl.textContent = "0";
                if (sharedEdgesEl) sharedEdgesEl.textContent = "0 m";
                if (externalPerimeterEl)
                    externalPerimeterEl.textContent = "0.00 m";
                if (internalDividersEl)
                    internalDividersEl.textContent = "0.00 m";
                if (totalFrameDisplayEl)
                    totalFrameDisplayEl.textContent = "0.00 m";
            }

            // Calculate curtain results with accurate framing
            function calculateCurtainResults(itemId) {
                const state = curtainDesignerStates.get(itemId);
                if (!state) return;

                // 1. Calculate external perimeter
                const externalPerimeter =
                    2 * (state.wallWidth + state.wallHeight);
                const externalPerimeterEl = document.getElementById(
                    `curtain-external-perimeter-${itemId}`
                );
                if (externalPerimeterEl)
                    externalPerimeterEl.textContent =
                        externalPerimeter.toFixed(2) + " m";

                // 2. Create a grid representation of the wall
                const grid = Array(state.rows)
                    .fill()
                    .map(() => Array(state.cols).fill(null));

                // Only consider top-level panels (non-merged cells are covered by merged panels)
                const topLevelPanels = state.panels.filter(
                    (panel) => !panel.mergedId
                );

                // Mark occupied cells in grid based on panel positions
                topLevelPanels.forEach((panel) => {
                    // Calculate how many cells this panel covers based on its position and size
                    const startRow = panel.row;
                    const startCol = panel.col;

                    // Calculate end positions based on percentage coverage
                    const endRow = Math.min(
                        state.rows - 1,
                        startRow +
                            Math.ceil(panel.height / (100 / state.rows)) -
                            1
                    );
                    const endCol = Math.min(
                        state.cols - 1,
                        startCol +
                            Math.ceil(panel.width / (100 / state.cols)) -
                            1
                    );

                    for (let r = startRow; r <= endRow; r++) {
                        for (let c = startCol; c <= endCol; c++) {
                            if (r < state.rows && c < state.cols) {
                                grid[r][c] = panel;
                            }
                        }
                    }
                });

                // 3. Calculate internal dividers
                let internalDividers = 0;
                const cellWidth = state.wallWidth / state.cols;
                const cellHeight = state.wallHeight / state.rows;

                // Vertical dividers (between columns)
                for (let row = 0; row < state.rows; row++) {
                    for (let col = 0; col < state.cols - 1; col++) {
                        const leftPanel = grid[row][col];
                        const rightPanel = grid[row][col + 1];

                        // Check if different panels and both exist
                        if (
                            leftPanel &&
                            rightPanel &&
                            leftPanel.id !== rightPanel.id
                        ) {
                            internalDividers += cellHeight;
                        }
                    }
                }

                // Horizontal dividers (between rows)
                for (let row = 0; row < state.rows - 1; row++) {
                    for (let col = 0; col < state.cols; col++) {
                        const topPanel = grid[row][col];
                        const bottomPanel = grid[row + 1][col];

                        // Check if different panels and both exist
                        if (
                            topPanel &&
                            bottomPanel &&
                            topPanel.id !== bottomPanel.id
                        ) {
                            internalDividers += cellWidth;
                        }
                    }
                }

                const internalDividersEl = document.getElementById(
                    `curtain-internal-dividers-${itemId}`
                );
                if (internalDividersEl)
                    internalDividersEl.textContent =
                        internalDividers.toFixed(2) + " m";

                // 4. Calculate total frame meters
                const totalFrameMeters = externalPerimeter + internalDividers;
                const frameMetersEl = document.getElementById(
                    `curtain-frame-meters-${itemId}`
                );
                const totalFrameDisplayEl = document.getElementById(
                    `curtain-total-frame-display-${itemId}`
                );
                if (frameMetersEl)
                    frameMetersEl.textContent = totalFrameMeters.toFixed(2);
                if (totalFrameDisplayEl)
                    totalFrameDisplayEl.textContent =
                        totalFrameMeters.toFixed(2) + " m";

                // 5. Calculate window/door specific metrics and total glass area
                let windowDoorMeters = 0;
                let glassArea = 0;
                let windowCount = 0;
                let doorCount = 0;

                topLevelPanels.forEach((panel) => {
                    // Glass area for ALL panels (use actual meter dimensions)
                    glassArea += panel.widthMeters * panel.heightMeters;

                    if (panel.type === "window") {
                        windowDoorMeters +=
                            2 * (panel.widthMeters + panel.heightMeters);
                        windowCount++;
                    } else if (panel.type === "door") {
                        windowDoorMeters +=
                            2 * (panel.widthMeters + panel.heightMeters);
                        doorCount++;
                    }
                });

                // 6. Calculate corners
                let cornerCount = 0;
                const vertexGrid = Array(state.rows + 1)
                    .fill()
                    .map(() => Array(state.cols + 1).fill(0));

                // Function to mark vertices for a panel
                function markPanelVertices(panel) {
                    const startRow = panel.row;
                    const startCol = panel.col;

                    // Calculate end positions based on percentage coverage
                    const endRow = Math.min(
                        state.rows,
                        startRow + Math.ceil(panel.height / (100 / state.rows))
                    );
                    const endCol = Math.min(
                        state.cols,
                        startCol + Math.ceil(panel.width / (100 / state.cols))
                    );

                    // Mark all four corners of the panel
                    vertexGrid[startRow][startCol] += 1; // Top-left
                    vertexGrid[startRow][endCol] += 1; // Top-right
                    vertexGrid[endRow][startCol] += 1; // Bottom-left
                    vertexGrid[endRow][endCol] += 1; // Bottom-right
                }

                // Mark vertices for all top-level panels
                topLevelPanels.forEach(markPanelVertices);

                // Count corners by checking vertices
                for (let i = 0; i <= state.rows; i++) {
                    for (let j = 0; j <= state.cols; j++) {
                        if (vertexGrid[i][j] > 0) {
                            // Count this as a corner if it's on the perimeter or where panels meet
                            if (
                                i === 0 ||
                                i === state.rows ||
                                j === 0 ||
                                j === state.cols ||
                                vertexGrid[i][j] > 1
                            ) {
                                cornerCount++;
                            }
                        }
                    }
                }

                // 7. Update display
                const windowMetersEl = document.getElementById(
                    `curtain-window-meters-${itemId}`
                );
                const glassAreaEl = document.getElementById(
                    `curtain-glass-area-${itemId}`
                );
                const cornerCountEl = document.getElementById(
                    `curtain-corner-count-${itemId}`
                );
                const panelCountEl = document.getElementById(
                    `curtain-panel-count-${itemId}`
                );
                const windowCountEl = document.getElementById(
                    `curtain-window-count-${itemId}`
                );
                const doorCountEl = document.getElementById(
                    `curtain-door-count-${itemId}`
                );
                const sharedEdgesEl = document.getElementById(
                    `curtain-shared-edges-${itemId}`
                );

                if (windowMetersEl)
                    windowMetersEl.textContent = windowDoorMeters.toFixed(2);
                if (glassAreaEl)
                    glassAreaEl.textContent = glassArea.toFixed(2) + " m";
                if (cornerCountEl) cornerCountEl.textContent = cornerCount;
                if (panelCountEl)
                    panelCountEl.textContent = topLevelPanels.length.toString();
                if (windowCountEl)
                    windowCountEl.textContent = windowCount.toString();
                if (doorCountEl) doorCountEl.textContent = doorCount.toString();
                if (sharedEdgesEl)
                    sharedEdgesEl.textContent =
                        internalDividers.toFixed(2) + " m";

                // 8. Highlight results
                if (frameMetersEl) {
                    frameMetersEl.parentElement.classList.add(
                        "curtain-highlight"
                    );
                    setTimeout(() => {
                        frameMetersEl.parentElement.classList.remove(
                            "curtain-highlight"
                        );
                    }, 1500);
                }
            }

            // Save curtain design
            function saveCurtainDesign(itemId) {
                const state = curtainDesignerStates.get(itemId);
                if (!state) return;

                const designData = {
                    cols: state.cols,
                    rows: state.rows,
                    wallWidth: state.wallWidth,
                    wallHeight: state.wallHeight,
                    columnSizes: state.columnSizes,
                    rowSizes: state.rowSizes,
                    frameMeters: parseFloat(
                        document.getElementById(
                            `curtain-frame-meters-${itemId}`
                        )?.textContent || "0"
                    ),
                    windowMeters: parseFloat(
                        document.getElementById(
                            `curtain-window-meters-${itemId}`
                        )?.textContent || "0"
                    ),
                    glassArea: parseFloat(
                        document
                            .getElementById(`curtain-glass-area-${itemId}`)
                            ?.textContent?.split(" ")[0] || "0"
                    ),
                    cornerCount: parseInt(
                        document.getElementById(
                            `curtain-corner-count-${itemId}`
                        )?.textContent || "0"
                    ),
                    panels: state.panels.map((panel) => ({
                        id: panel.id,
                        row: panel.row,
                        col: panel.col,
                        width: panel.width,
                        height: panel.height,
                        type: panel.type,
                        merged: panel.merged,
                        mergedId: panel.mergedId,
                        mergedPanels: panel.mergedPanels || [],
                    })),
                    timestamp: new Date().toISOString(),
                };

                // Update the item's curtain data
                const item = items.find((item) => item.id === itemId);
                if (item && item.type === "curtain_wall") {
                    item.curtain.designData = designData;
                    item.curtain.wallWidth = designData.wallWidth;
                    item.curtain.wallHeight = designData.wallHeight;
                    item.curtain.frameMeters = designData.frameMeters;
                    item.curtain.windowMeters = designData.windowMeters;
                    item.curtain.glassArea = designData.glassArea;
                    item.curtain.cornerCount = designData.cornerCount;
                    item.curtain.panels = designData.panels;
                    item.curtain.visualSvg = generateCurtainWallSvg(designData);
                }

                // Hide designer, show summary
                const curtainDesigner = document.querySelector(
                    `#curtainWallDesigner-${itemId}`
                );
                const curtainSummary = document.querySelector(
                    `#curtainWallSummary-${itemId}`
                );

                if (curtainDesigner && curtainSummary) {
                    curtainDesigner.style.display = "none";
                    curtainSummary.style.display = "block";

                    // Update the summary display
                    const shapeEl = curtainSummary.querySelector(
                        `#curtainWallShape-${itemId}`
                    );
                    if (shapeEl && item && item.curtain.visualSvg) {
                        shapeEl.innerHTML = item.curtain.visualSvg;
                    }

                    // Add hidden input with design data
                    let hiddenInput = curtainSummary.querySelector(
                        'input[name="curtainWallData"]'
                    );
                    if (!hiddenInput) {
                        hiddenInput = document.createElement("input");
                        hiddenInput.type = "hidden";
                        hiddenInput.name = "curtainWallData";
                        curtainSummary.appendChild(hiddenInput);
                    }
                    hiddenInput.value = JSON.stringify(designData);
                }

                alert("Curtain wall design saved successfully!");
            }

            // Initialize curtain wall designer when item type changes to curtain_wall
            function initializeCurtainWallDesigner(itemId) {
                // Wait a bit for the DOM to be ready
                setTimeout(() => {
                    initCurtainWallDesigner(itemId);
                }, 100);
            }

            // Override the updateItemType function to initialize curtain wall designer
            const originalUpdateItemType = updateItemType;
            updateItemType = function (itemId, type) {
                originalUpdateItemType(itemId, type);

                if (type === "curtain_wall") {
                    initializeCurtainWallDesigner(itemId);
                }
            };

            // Function to load saved design data into curtain wall designer
            function loadCurtainDesignData(itemId, data) {
                const state = curtainDesignerStates.get(itemId);
                if (!state || !data) return;

                console.log(
                    "Loading curtain wall design data for item:",
                    itemId,
                    data
                );

                // Update form fields
                const panelColsInput = document.getElementById(
                    `curtain-panel-cols-${itemId}`
                );
                const panelRowsInput = document.getElementById(
                    `curtain-panel-rows-${itemId}`
                );
                const wallWidthInput = document.getElementById(
                    `curtain-wall-width-${itemId}`
                );
                const wallHeightInput = document.getElementById(
                    `curtain-wall-height-${itemId}`
                );

                if (panelColsInput) panelColsInput.value = data.cols || 4;
                if (panelRowsInput) panelRowsInput.value = data.rows || 3;
                if (wallWidthInput)
                    wallWidthInput.value = data.wallWidth || 4.0;
                if (wallHeightInput)
                    wallHeightInput.value = data.wallHeight || 3.0;

                // Update state
                state.cols = data.cols || 4;
                state.rows = data.rows || 3;
                state.wallWidth = data.wallWidth || 4.0;
                state.wallHeight = data.wallHeight || 3.0;
                state.columnSizes =
                    data.columnSizes || Array(state.cols).fill(1);
                state.rowSizes = data.rowSizes || Array(state.rows).fill(1);

                // Initialize grid first
                initCurtainGrid(itemId);

                // Update size inputs
                updateSizeInputs(itemId);

                // Wait a bit for grid to be created, then restore panel states
                setTimeout(() => {
                    if (data.panels && data.panels.length > 0) {
                        console.log(
                            "Restoring panel states for item:",
                            itemId,
                            data.panels
                        );

                        // Restore panel types and merged states
                        data.panels.forEach((panelData) => {
                            const panel = state.panels.find(
                                (p) =>
                                    p.row === panelData.row &&
                                    p.col === panelData.col
                            );
                            if (panel && !panelData.merged) {
                                // Only restore non-merged panels initially
                                if (panelData.type) {
                                    panel.type = panelData.type;
                                    updateCurtainPanelElement(itemId, panel.id);
                                }
                            }
                        });

                        // Restore merged panels
                        const mergedPanels = data.panels.filter(
                            (p) =>
                                p.merged &&
                                p.mergedPanels &&
                                p.mergedPanels.length > 0
                        );
                        mergedPanels.forEach((mergedPanelData) => {
                            // Find the original panels that were merged
                            const originalPanelIds = [];
                            mergedPanelData.mergedPanels.forEach(
                                (originalId) => {
                                    const originalPanelData = data.panels.find(
                                        (p) => p.id === originalId
                                    );
                                    if (originalPanelData) {
                                        const currentPanel = state.panels.find(
                                            (p) =>
                                                p.row ===
                                                    originalPanelData.row &&
                                                p.col === originalPanelData.col
                                        );
                                        if (currentPanel) {
                                            originalPanelIds.push(
                                                currentPanel.id
                                            );
                                        }
                                    }
                                }
                            );

                            if (originalPanelIds.length > 1) {
                                // Select the panels and merge them
                                state.selectedPanels.clear();
                                originalPanelIds.forEach((id) =>
                                    state.selectedPanels.add(id)
                                );
                                updateCurtainPanelSelection(itemId);
                                mergeCurtainPanels(itemId);

                                // Set the type of the merged panel
                                if (mergedPanelData.type) {
                                    const mergedPanel = Array.from(
                                        state.mergedPanels.values()
                                    ).find(
                                        (mp) =>
                                            mp.row === mergedPanelData.row &&
                                            mp.col === mergedPanelData.col
                                    );
                                    if (mergedPanel) {
                                        mergedPanel.type = mergedPanelData.type;
                                        updateCurtainPanelElement(
                                            itemId,
                                            mergedPanel.id
                                        );
                                    }
                                }
                            }
                        });

                        // Clear selection and recalculate
                        state.selectedPanels.clear();
                        updateCurtainPanelSelection(itemId);
                        calculateCurtainResults(itemId);

                        console.log(
                            "Design data loaded successfully for item:",
                            itemId
                        );
                    } else {
                        console.log(
                            "No panel data to restore for item:",
                            itemId
                        );
                    }
                }, 500);
            }

            // NEW FUNCTION: Generates SVG string for curtain wall - FIXED to match original logic
            // ENHANCED FUNCTION: Generates SVG string for curtain wall with accurate ratio representation
            function generateCurtainWallSvg(data) {
                console.log("generateCurtainWallSvg called with data:", data);
                if (!data || !data.panels) {
                    console.log(
                        "No data or panels found, returning error message"
                    );
                    return "<em>No design data available</em>";
                }

                // Fixed consistent dimensions for all SVGs
                const fixedSvgWidth = 240;
                const fixedSvgHeight = 160;
                const padding = 15;

                // Filter panels to render (exclude merged children but include merged parents)
                const panelsToRender = data.panels.filter(
                    (panel) => !panel.mergedId // Only show panels that aren't merged into another panel
                );

                if (panelsToRender.length === 0) {
                    return "<em>No panels to display</em>";
                }

                // Calculate the total wall dimensions from panel data
                const totalWallWidth = data.wallWidth || 4.0;
                const totalWallHeight = data.wallHeight || 3.0;

                // Calculate available space for the curtain wall
                const availableWidth = fixedSvgWidth - padding * 2;
                const availableHeight = fixedSvgHeight - padding * 2;

                // Calculate consistent size for curtain walls
                const baseMaxSize =
                    Math.min(availableWidth, availableHeight) * 0.8; // 80% of available space

                // Adjust size based on number of panels
                const panelCount = panelsToRender.length;
                let panelMultiplier = 1;
                if (panelCount > 1) {
                    // Scale up based on number of panels to show complexity
                    panelMultiplier = Math.min(panelCount * 0.2 + 0.8, 1.8); // Max 1.8x for very complex curtain walls
                }

                const maxSize = baseMaxSize * panelMultiplier;
                const wallRatio = totalWallWidth / totalWallHeight;

                let contentWidth, contentHeight;
                if (wallRatio > 1) {
                    // Wide walls
                    contentWidth = maxSize;
                    contentHeight = maxSize / wallRatio;
                } else {
                    // Tall walls
                    contentHeight = maxSize;
                    contentWidth = maxSize * wallRatio;
                }

                // Center the content within the fixed SVG
                const offsetX = (fixedSvgWidth - contentWidth) / 2;
                const offsetY = (fixedSvgHeight - contentHeight) / 2;

                // Generate unique ID for gradients
                const gradientId = `glassGradient_${Math.random()
                    .toString(36)
                    .substr(2, 9)}`;
                const reflectionId = `glassReflection_${Math.random()
                    .toString(36)
                    .substr(2, 9)}`;

                // Panel colors and labels - Enhanced to match the image
                const panelStyles = {
                    structure: {
                        color: "#e3f2fd",
                        stroke: "#1976d2",
                        label: "F",
                    },
                    window: {
                        color: `url(#${gradientId})`,
                        stroke: "#42a5f5",
                        label: "",
                    },
                    door: { color: "#ffecb3", stroke: "#ffca28", label: "D" },
                };

                // Define gradients for glass effect
                const gradientDefs = `
                <defs>
                    <linearGradient id="${gradientId}" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#e3f2fd;stop-opacity:0.9" />
                        <stop offset="25%" style="stop-color:#bbdefb;stop-opacity:0.7" />
                        <stop offset="50%" style="stop-color:#90caf9;stop-opacity:0.5" />
                        <stop offset="75%" style="stop-color:#64b5f6;stop-opacity:0.7" />
                        <stop offset="100%" style="stop-color:#42a5f5;stop-opacity:0.9" />
                    </linearGradient>
                    <linearGradient id="${reflectionId}" x1="0%" y1="0%" x2="30%" y2="30%">
                        <stop offset="0%" style="stop-color:#ffffff;stop-opacity:0.6" />
                        <stop offset="50%" style="stop-color:#ffffff;stop-opacity:0.2" />
                        <stop offset="100%" style="stop-color:#ffffff;stop-opacity:0" />
                    </linearGradient>
                </defs>
            `;

                let svgContent = "";

                // Render panels with accurate ratio representation
                panelsToRender.forEach((panel) => {
                    console.log("Processing panel:", panel);
                    const style = panelStyles[panel.type] || {
                        color: "#f0f0f0",
                        stroke: "#ddd",
                        label: "",
                    };

                    // Use actual panel dimensions in meters to calculate SVG positions
                    const panelWidthMeters = panel.widthMeters || 0;
                    const panelHeightMeters = panel.heightMeters || 0;

                    // Calculate panel position and size in SVG coordinates
                    // Fallback to grid-based positioning if left/top are not available
                    let panelX, panelY;
                    if (panel.left !== undefined && panel.top !== undefined) {
                        panelX = offsetX + (panel.left / 100) * contentWidth;
                        panelY = offsetY + (panel.top / 100) * contentHeight;
                    } else {
                        // Fallback to grid-based positioning
                        const gridCols = data.cols || 4;
                        const gridRows = data.rows || 3;
                        const cellWidth = contentWidth / gridCols;
                        const cellHeight = contentHeight / gridRows;
                        panelX = offsetX + (panel.col || 0) * cellWidth;
                        panelY = offsetY + (panel.row || 0) * cellHeight;
                    }

                    let panelWidth, panelHeight;
                    if (panelWidthMeters > 0 && panelHeightMeters > 0) {
                        panelWidth =
                            (panelWidthMeters / totalWallWidth) * contentWidth;
                        panelHeight =
                            (panelHeightMeters / totalWallHeight) *
                            contentHeight;
                    } else {
                        // Fallback to grid-based sizing
                        const gridCols = data.cols || 4;
                        const gridRows = data.rows || 3;
                        const cellWidth = contentWidth / gridCols;
                        const cellHeight = contentHeight / gridRows;
                        panelWidth = cellWidth;
                        panelHeight = cellHeight;
                    }

                    // Panel rectangle with rounded corners
                    svgContent += `
                    <rect x="${panelX}" y="${panelY}" width="${panelWidth}" height="${panelHeight}"
                          fill="${style.color}" stroke="black" stroke-width="3" rx="4" ry="4"/>
                `;

                    // Special handling for windows with divided panels (matching the image)
                    if (panel.type === "window") {
                        // Add glass reflection effect
                        svgContent += `
                        <rect x="${panelX + 2}" y="${panelY + 2}" width="${
                            panelWidth * 0.3
                        }" height="${panelHeight * 0.4}"
                              fill="url(#${reflectionId})" stroke="none" rx="2" ry="2"/>
                    `;

                        // Add window frame lines for larger panels (matching the divided panels in image)
                        if (panelWidth > 20 && panelHeight > 20) {
                            // Vertical center line
                            svgContent += `
                            <line x1="${
                                panelX + panelWidth / 2
                            }" y1="${panelY}" x2="${
                                panelX + panelWidth / 2
                            }" y2="${panelY + panelHeight}"
                                  stroke="black" stroke-width="3" opacity="0.9"/>
                        `;

                            // Horizontal center line
                            svgContent += `
                            <line x1="${panelX}" y1="${
                                panelY + panelHeight / 2
                            }" x2="${panelX + panelWidth}" y2="${
                                panelY + panelHeight / 2
                            }"
                                  stroke="black" stroke-width="3" opacity="0.9"/>
                        `;

                            // V-shape division - extends fully to panel edges
                            const centerX = panelX + panelWidth / 2;
                            const centerY = panelY + panelHeight / 2;
                            svgContent += `
                            <line x1="${panelX}" y1="${panelY}" x2="${centerX}" y2="${centerY}"
                                  stroke="black" stroke-width="3" opacity="0.9"/>
                            <line x1="${
                                panelX + panelWidth
                            }" y1="${panelY}" x2="${centerX}" y2="${centerY}"
                                  stroke="black" stroke-width="3" opacity="0.9"/>
                        `;
                        }
                    }

                    // Panel label (for structure and door panels)
                    if (panel.type && panel.type !== "window" && style.label) {
                        const centerX = panelX + panelWidth / 2;
                        const centerY = panelY + panelHeight / 2;
                        const fontSize = Math.min(panelWidth, panelHeight) / 4;

                        svgContent += `
                        <text x="${centerX}" y="${centerY}"
                              font-family="Arial, sans-serif" font-size="${Math.max(
                                  fontSize,
                                  10
                              )}"
                              fill="${
                                  style.stroke
                              }" text-anchor="middle" font-weight="bold"
                              dominant-baseline="middle">
                            ${style.label}
                        </text>
                    `;
                    }
                });

                // Outer border with rounded corners - represents the actual wall dimensions
                svgContent = `
                <rect x="${offsetX}" y="${offsetY}" width="${contentWidth}" height="${contentHeight}"
                      fill="none" stroke="#A72036" stroke-width="2" rx="6" ry="6"/>
                ${svgContent}
            `;

                const finalSvg = `
                <svg width="${fixedSvgWidth}" height="${fixedSvgHeight}"
                     viewBox="0 0 ${fixedSvgWidth} ${fixedSvgHeight}"
                     xmlns="http://www.w3.org/2000/svg">
                    ${gradientDefs}
                    ${svgContent}
                </svg>
            `;

                console.log("Generated final SVG, length:", finalSvg.length);
                return finalSvg;
            }

            // ENHANCED FUNCTION: Generates SVG string for normal items with proper system representation
            function generateNormalItemSvg(item) {
                console.log("generateNormalItemSvg called with item:", item);
                if (!item || !item.width || !item.height) {
                    console.log(
                        "No item data or dimensions found, returning error message"
                    );
                    return "<em>No item data available</em>";
                }

                // Fixed consistent dimensions for all SVGs
                const fixedSvgWidth = 240;
                const fixedSvgHeight = 160;
                const padding = 20;

                // Calculate consistent size for all items
                const availableWidth = fixedSvgWidth - padding * 2;
                const availableHeight = fixedSvgHeight - padding * 2;

                // Adjust size based on number of leaves
                let leafMultiplier = 1;
                if (item.leaves > 1) {
                    // Scale up based on number of leaves to show complexity
                    leafMultiplier = Math.min(item.leaves * 0.3 + 0.7, 1.5); // Max 1.5x for very complex items
                }

                // Use consistent size for all items (maintain aspect ratio within bounds)
                const baseMaxSize =
                    Math.min(availableWidth, availableHeight) * 0.8; // 80% of available space
                const maxSize = baseMaxSize * leafMultiplier;
                const itemRatio = item.width / item.height;

                let contentWidth, contentHeight;
                if (itemRatio > 1) {
                    // Wide items
                    contentWidth = maxSize;
                    contentHeight = maxSize / itemRatio;
                } else {
                    // Tall items
                    contentHeight = maxSize;
                    contentWidth = maxSize * itemRatio;
                }

                // Center the content within the fixed SVG
                const offsetX = (fixedSvgWidth - contentWidth) / 2;
                const offsetY = (fixedSvgHeight - contentHeight) / 2;

                // Generate unique ID for gradients
                const gradientId = `glassGradient_${Math.random()
                    .toString(36)
                    .substr(2, 9)}`;
                const reflectionId = `glassReflection_${Math.random()
                    .toString(36)
                    .substr(2, 9)}`;

                // Item colors and labels based on type
                const itemStyles = {
                    window: {
                        color: `url(#${gradientId})`,
                        stroke: "#42a5f5",
                        label: "W",
                        frameColor: "#1976d2",
                    },
                    door: {
                        color: "#ffecb3",
                        stroke: "#ffca28",
                        label: "D",
                        frameColor: "#f57c00",
                    },
                    sliding_door: {
                        color: "#e8f5e8",
                        stroke: "#4caf50",
                        label: "S",
                        frameColor: "#2e7d32",
                    },
                };

                const style = itemStyles[item.type] || itemStyles["window"];

                // Define gradients for glass effect
                const gradientDefs = `
                <defs>
                    <linearGradient id="${gradientId}" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#e3f2fd;stop-opacity:0.9" />
                        <stop offset="25%" style="stop-color:#bbdefb;stop-opacity:0.7" />
                        <stop offset="50%" style="stop-color:#90caf9;stop-opacity:0.5" />
                        <stop offset="75%" style="stop-color:#64b5f6;stop-opacity:0.7" />
                        <stop offset="100%" style="stop-color:#42a5f5;stop-opacity:0.9" />
                    </linearGradient>
                    <linearGradient id="${reflectionId}" x1="0%" y1="0%" x2="30%" y2="30%">
                        <stop offset="0%" style="stop-color:#ffffff;stop-opacity:0.6" />
                        <stop offset="50%" style="stop-color:#ffffff;stop-opacity:0.2" />
                        <stop offset="100%" style="stop-color:#ffffff;stop-opacity:0" />
                    </linearGradient>
                </defs>
            `;

                let svgContent = "";

                // Handle different system types with appropriate layouts
                if (item.system === "Sliding") {
                    // Sliding system: panels side by side with arrows
                    svgContent += `
                    <rect x="${offsetX}" y="${offsetY}" width="${contentWidth}" height="${contentHeight}"
                          fill="${style.color}" stroke="black" stroke-width="3" rx="6" ry="6"/>
                `;

                    // Add glass reflection effect
                    svgContent += `
                    <rect x="${offsetX + 4}" y="${offsetY + 4}" width="${
                        contentWidth * 0.3
                    }" height="${contentHeight * 0.4}"
                          fill="url(#${reflectionId})" stroke="none" rx="3" ry="3"/>
                `;

                    // Add frame divisions for leaves (side by side)
                    if (item.leaves > 1) {
                        const leafWidth = contentWidth / item.leaves;
                        for (let i = 1; i < item.leaves; i++) {
                            const x = offsetX + i * leafWidth;
                            svgContent += `
                            <line x1="${x}" y1="${offsetY}" x2="${x}" y2="${
                                offsetY + contentHeight
                            }"
                                  stroke="black" stroke-width="3" opacity="0.9"/>
                        `;
                        }
                    }

                    // Add sliding arrows for each leaf
                    const arrowSize =
                        Math.min(contentWidth, contentHeight) * 0.12;
                    const leafWidth = contentWidth / item.leaves;

                    for (let i = 0; i < item.leaves; i++) {
                        const leafCenterX =
                            offsetX + i * leafWidth + leafWidth / 2;
                        const arrowY = offsetY + contentHeight / 2;

                        // Left arrow (pointing right) - positioned at left edge of each leaf
                        const leftArrowX =
                            offsetX + i * leafWidth + leafWidth * 0.25;
                        svgContent += `
                        <polygon points="${leftArrowX - arrowSize / 2},${
                            arrowY - arrowSize / 2
                        } ${leftArrowX + arrowSize / 2},${arrowY} ${
                            leftArrowX - arrowSize / 2
                        },${arrowY + arrowSize / 2}"
                                  fill="black" opacity="0.9"/>
                    `;

                        // Right arrow (pointing left) - positioned at right edge of each leaf
                        const rightArrowX =
                            offsetX + i * leafWidth + leafWidth * 0.75;
                        svgContent += `
                        <polygon points="${rightArrowX + arrowSize / 2},${
                            arrowY - arrowSize / 2
                        } ${rightArrowX - arrowSize / 2},${arrowY} ${
                            rightArrowX + arrowSize / 2
                        },${arrowY + arrowSize / 2}"
                                  fill="black" opacity="0.9"/>
                    `;
                    }
                } else if (item.system === "hinged") {
                    // Hinged system: panels stacked vertically with triangle shapes
                    const panelHeight = contentHeight / item.leaves;

                    // Get upper panel type for 2-leaf hinged systems
                    let upperPanelType = "hinged"; // default
                    if (item.leaves === 2) {
                        const itemElement = document.getElementById(item.id);
                        if (itemElement) {
                            const upperPanelSelect = itemElement.querySelector(
                                ".item-upper-panel-type"
                            );
                            if (upperPanelSelect) {
                                upperPanelType = upperPanelSelect.value;
                            }
                        }
                    }

                    for (let i = 0; i < item.leaves; i++) {
                        const panelY = offsetY + i * panelHeight;
                        const isUpperPanel = i === 0; // First panel (top) is upper panel

                        // Panel rectangle
                        svgContent += `
                        <rect x="${offsetX}" y="${panelY}" width="${contentWidth}" height="${panelHeight}"
                              fill="${style.color}" stroke="black" stroke-width="3" rx="4" ry="4"/>
                    `;

                        // Add glass reflection effect
                        svgContent += `
                        <rect x="${offsetX + 2}" y="${panelY + 2}" width="${
                            contentWidth * 0.3
                        }" height="${panelHeight * 0.4}"
                              fill="url(#${reflectionId})" stroke="none" rx="2" ry="2"/>
                    `;

                        // Add visual indicator based on panel type
                        if (contentWidth > 30 && panelHeight > 20) {
                            const centerX = offsetX + contentWidth / 2;
                            const centerY = panelY + panelHeight / 2;

                            if (
                                isUpperPanel &&
                                item.leaves === 2 &&
                                upperPanelType === "fixed"
                            ) {
                                // Upper panel is fixed - show F character
                                const fontSize =
                                    Math.min(contentWidth, panelHeight) / 4;
                                svgContent += `
                                <text x="${centerX}" y="${centerY}"
                                      font-family="Arial, sans-serif" font-size="${Math.max(
                                          fontSize,
                                          16
                                      )}"
                                      fill="black" text-anchor="middle" font-weight="bold"
                                      dominant-baseline="middle">
                                    F
                                </text>
                            `;
                            } else {
                                // Hinged panel - show V-shape
                                svgContent += `
                                <line x1="${offsetX}" y1="${panelY}" x2="${centerX}" y2="${centerY}"
                                      stroke="black" stroke-width="3" opacity="0.9"/>
                                <line x1="${
                                    offsetX + contentWidth
                                }" y1="${panelY}" x2="${centerX}" y2="${centerY}"
                                      stroke="black" stroke-width="3" opacity="0.9"/>
                            `;
                            }
                        }
                    }
                } else if (item.system === "fixed") {
                    // Fixed system: multiple panels stacked vertically with F character on each
                    const panelHeight = contentHeight / item.leaves;

                    for (let i = 0; i < item.leaves; i++) {
                        const panelY = offsetY + i * panelHeight;

                        // Panel rectangle
                        svgContent += `
                        <rect x="${offsetX}" y="${panelY}" width="${contentWidth}" height="${panelHeight}"
                              fill="${style.color}" stroke="black" stroke-width="3" rx="4" ry="4"/>
                    `;

                        // Add glass reflection effect
                        svgContent += `
                        <rect x="${offsetX + 2}" y="${panelY + 2}" width="${
                            contentWidth * 0.3
                        }" height="${panelHeight * 0.4}"
                              fill="url(#${reflectionId})" stroke="none" rx="2" ry="2"/>
                    `;

                        // Add F character for each fixed panel
                        if (contentWidth > 30 && panelHeight > 20) {
                            const centerX = offsetX + contentWidth / 2;
                            const centerY = panelY + panelHeight / 2;
                            const fontSize =
                                Math.min(contentWidth, panelHeight) / 4;

                            svgContent += `
                            <text x="${centerX}" y="${centerY}"
                                  font-family="Arial, sans-serif" font-size="${Math.max(
                                      fontSize,
                                      16
                                  )}"
                                  fill="black" text-anchor="middle" font-weight="bold"
                                  dominant-baseline="middle">
                                F
                            </text>
                        `;
                        }
                    }
                } else {
                    // Default layout for other systems
                    svgContent += `
                    <rect x="${offsetX}" y="${offsetY}" width="${contentWidth}" height="${contentHeight}"
                          fill="${style.color}" stroke="black" stroke-width="3" rx="6" ry="6"/>
                `;

                    // Add glass reflection effect
                    svgContent += `
                    <rect x="${offsetX + 4}" y="${offsetY + 4}" width="${
                        contentWidth * 0.3
                    }" height="${contentHeight * 0.4}"
                          fill="url(#${reflectionId})" stroke="none" rx="3" ry="3"/>
                `;

                    // Add frame details based on leaves
                    if (item.leaves > 1) {
                        const leafWidth = contentWidth / item.leaves;
                        for (let i = 1; i < item.leaves; i++) {
                            const x = offsetX + i * leafWidth;
                            svgContent += `
                            <line x1="${x}" y1="${offsetY}" x2="${x}" y2="${
                                offsetY + contentHeight
                            }"
                                  stroke="black" stroke-width="3" opacity="0.9"/>
                        `;
                        }
                    }
                }

                // Add item label (only for doors and sliding doors, not windows or fixed items)
                if (item.system !== "fixed" && item.type !== "window") {
                    const centerX = offsetX + contentWidth / 2;
                    const centerY = offsetY + contentHeight / 2;
                    const fontSize = Math.min(contentWidth, contentHeight) / 6;

                    svgContent += `
                    <text x="${centerX}" y="${centerY}"
                          font-family="Arial, sans-serif" font-size="${Math.max(
                              fontSize,
                              16
                          )}"
                          fill="${
                              style.stroke
                          }" text-anchor="middle" font-weight="bold"
                          dominant-baseline="middle">
                        ${style.label}
                    </text>
                `;
                }

                // Add dimensions text
                const centerX = offsetX + contentWidth / 2;
                const dimText = `${item.width}m  ${item.height}m`;
                const dimFontSize = Math.max(
                    Math.min(contentWidth, contentHeight) / 12,
                    10
                );

                svgContent += `
                <text x="${centerX}" y="${
                    offsetY + contentHeight + dimFontSize + 5
                }"
                      font-family="Arial, sans-serif" font-size="${dimFontSize}"
                      fill="#666" text-anchor="middle" font-weight="normal"
                      dominant-baseline="middle">
                    ${dimText}
                </text>
            `;

                const finalSvg = `
                <svg width="${fixedSvgWidth}" height="${fixedSvgHeight}"
                     viewBox="0 0 ${fixedSvgWidth} ${fixedSvgHeight}"
                     xmlns="http://www.w3.org/2000/svg">
                    ${gradientDefs}
                    ${svgContent}
                </svg>
            `;

                console.log(
                    "Generated final normal item SVG, length:",
                    finalSvg.length
                );
                return finalSvg;
            }

            // Function to regenerate SVG and update summary for any field change
            function regenerateItemSvg(itemId) {
                const item = items.find((item) => item.id === itemId);
                if (!item || item.type === "curtain_wall") return;

                // Update item data from form fields
                const itemElement = document.getElementById(itemId);
                if (itemElement) {
                    // Update upper panel type if it exists
                    const upperPanelSelect = itemElement.querySelector(
                        ".item-upper-panel-type"
                    );
                    if (upperPanelSelect) {
                        item.upperPanelType = upperPanelSelect.value;
                        console.log(
                            "Updated item.upperPanelType to:",
                            item.upperPanelType
                        );
                    }
                }

                // Regenerate SVG
                item.visualSvg = generateNormalItemSvg(item);

                // Update the summary display
                updateNormalItemSummary(itemId);
            }

            // Function to update normal item summary with SVG
            function updateNormalItemSummary(itemId) {
                const item = items.find((item) => item.id === itemId);
                if (!item || item.type === "curtain_wall") return;

                const itemElement = document.getElementById(itemId);
                if (!itemElement) return;

                const summaryEl = itemElement.querySelector(
                    `#normalItemSummary-${itemId}`
                );
                const shapeEl = itemElement.querySelector(
                    `#normalItemShape-${itemId}`
                );
                const detailsEl = itemElement.querySelector(
                    `#normalItemDetails-${itemId}`
                );
                const statsEl = itemElement.querySelector(
                    `#normalItemStats-${itemId}`
                );

                if (!summaryEl || !shapeEl || !detailsEl || !statsEl) return;

                // Show the summary
                summaryEl.style.display = "block";

                // Update the SVG
                if (item.visualSvg) {
                    shapeEl.innerHTML = item.visualSvg;
                } else {
                    shapeEl.innerHTML =
                        "<em>No visual representation available</em>";
                }

                // Update details
                detailsEl.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                    <div><strong>Type:</strong> ${
                        item.type
                            ? item.type.charAt(0).toUpperCase() +
                              item.type.slice(1)
                            : "Not selected"
                    }</div>
                    <div><strong>System:</strong> ${
                        item.system || "Not selected"
                    }</div>
                    <div><strong>Dimensions:</strong> ${item.width || 0}m  ${
                    item.height || 0
                }m</div>
                    <div><strong>Leaves:</strong> ${item.leaves || 0}</div>
                    <div><strong>Glass Type:</strong> ${
                        item.glassType || "double"
                    }</div>
                    <div><strong>Quantity:</strong> ${item.quantity || 1}</div>
                </div>
            `;

                // Update stats
                if (item.width && item.height) {
                    const area = (
                        item.width *
                        item.height *
                        item.quantity
                    ).toFixed(2);
                    const perimeter = (
                        (item.width + item.height) *
                        2 *
                        item.leaves *
                        item.quantity
                    ).toFixed(2);

                    statsEl.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; background: #f0f0f0; padding: 10px; border-radius: 5px;">
                        <div><strong>Total Area:</strong> ${area} m</div>
                        <div><strong>Frame Length:</strong> ${perimeter} m</div>
                    </div>
                `;
                } else {
                    statsEl.innerHTML =
                        "<em>Enter dimensions to see calculations</em>";
                }
            }

            // TEST FUNCTION: Call this from console to test SVG generation
            function testSvgGeneration() {
                console.log("Testing SVG generation...");

                // Test different system types
                const testItems = [
                    {
                        id: "test-sliding",
                        type: "window",
                        width: 2.0,
                        height: 1.5,
                        leaves: 2,
                        system: "Sliding",
                    },
                    {
                        id: "test-hinged",
                        type: "door",
                        width: 1.2,
                        height: 2.4,
                        leaves: 2,
                        system: "hinged",
                    },
                    {
                        id: "test-fixed",
                        type: "window",
                        width: 1.0,
                        height: 1.0,
                        leaves: 1,
                        system: "fixed",
                    },
                ];

                let testSvgs = "";
                testItems.forEach((item) => {
                    const svg = generateNormalItemSvg(item);
                    testSvgs += `
                    <h4>${item.system} System (${item.leaves} leaf${
                        item.leaves > 1 ? "s" : ""
                    }):</h4>
                    <div style="border: 1px solid #ccc; padding: 10px; margin: 10px;">${svg}</div>
                `;
                });

                // Test curtain wall SVG
                const testCurtainData = {
                    wallWidth: 4.0,
                    wallHeight: 3.0,
                    cols: 4,
                    rows: 3,
                    panels: [
                        {
                            id: 1,
                            row: 0,
                            col: 0,
                            widthMeters: 1.0,
                            heightMeters: 1.0,
                            left: 0,
                            top: 0,
                            type: "structure",
                        },
                        {
                            id: 2,
                            row: 0,
                            col: 1,
                            widthMeters: 1.0,
                            heightMeters: 1.0,
                            left: 25,
                            top: 0,
                            type: "window",
                        },
                    ],
                };

                const curtainSvg = generateCurtainWallSvg(testCurtainData);
                console.log("Curtain wall SVG generated:", curtainSvg);

                // Display test SVGs
                const testDiv = document.createElement("div");
                testDiv.innerHTML = `
                <h3>SVG Test Results</h3>
                <h4>Normal Items (Different Systems):</h4>
                ${testSvgs}
                <h4>Curtain Wall SVG:</h4>
                <div style="border: 1px solid #ccc; padding: 10px; margin: 10px;">${curtainSvg}</div>
            `;
                document.body.appendChild(testDiv);
            }
        </script>
    </body>
</html>
